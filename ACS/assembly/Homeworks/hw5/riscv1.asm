.data
digit_codes:
    .byte 0x3F  # 0 начиная отсюда и вниз, это все сегменты, которые отвечают за цифрерки на экране
    .byte 0x06  # 1  
    .byte 0x5B  # 2
    .byte 0x4F  # 3
    .byte 0x66  # 4
    .byte 0x6D  # 5
    .byte 0x7D  # 6
    .byte 0x07  # 7
    .byte 0x7F  # 8
    .byte 0x6F  # 9
    .byte 0x77  # A
    .byte 0x7C  # b
    .byte 0x39  # C
    .byte 0x5E  # d
    .byte 0x79  # E
    .byte 0x71  # F

.text #секция кода
.globl main #глобальная метка

main:
    li s0, 0xffff0010 #загружаем в регистр s0 адрес индикатора 
    #Byte value at address 0xffff0010 : command right seven segment display
    #s0 теперь содержит адрес устройства вывода
    # Счетчик (0-15)
    li s1, 0 #загружает в регистр s1 начальное значение 0 (наш счетчик)
    #s1 будет хранить текущую цифру (0-15)
    # Адрес таблицы кодов
    la s2, digit_codes #загружает в регистр s2 адрес таблицы кодов (Load Address)
    #s2 указывает на начало массива с кодами сегментов

main_loop: #начинаем бесконечный цикл
    add t0, s2, s1 #вычисляеv адрес нужного кода в таблице
    #где у нас t0 = адрес_таблицы + номер_цифры
    lb t1, 0(t0) #загружаеv байт из памяти в регистр t1 (Load Byte)
    sb t1, 0(s0) # сохраняеm байт из t1 в память (Store Byte)
    #и оно же отправляет код сегментов на индикатор по адресу в s0
    
    #Увеличиваем счетчик (0-15)
    addi s1, s1, 1 #тут увеличиваем счетчик на 1
    andi s1, s1, 0x0F #обнуляеm старшие биты, оставляя только младшие 4 (AND Immediate)
    
    j main_loop #переход к метке мейна, создаем бесконечный цикл