# Подпрограмма, вычисляющая квадратный корень (итерационная формула) -> Ньютон
.text
# Метка начала подпрограммы вычисления квадратного корня
sqrt_iterative:
    # Сохранение регистров в стеке (пролог функции)
    addi sp, sp, -20        # Выделяем 20 байт в стеке для сохранения 5 регистров (4 float + 1 integer)
    fsw fs0, 16(sp)         # Сохраняем регистр fs0 в стек по смещению 16 (сохраняем предыдущее значение)
    fsw fs1, 12(sp)         # Сохраняем регистр fs1 в стек по смещению 12
    fsw fs2, 8(sp)          # Сохраняем регистр fs2 в стек по смещению 8
    fsw fs3, 4(sp)          # Сохраняем регистр fs3 в стек по смещению 4
    sw ra, 0(sp)            # Сохраняем адрес возврата (ra) в стек по смещению 0
    
    # Сохранение аргументов, переданных в подпрограмму
    fmv.s fs0, fa0          # Копируем первый аргумент (число a) из fa0 в fs0 для постоянного хранения
    fmv.s fs1, fa1          # Копируем второй аргумент (точность ε) из fa1 в fs1 для постоянного хранения
    
    # Начальное приближение: x₀ = a / 2
    li t0, 2                # Загружаем целое число 2 в регистр t0
    fcvt.s.w fs3, t0        # Конвертируем целое число 2 из t0 в float и сохраняем в fs3 (теперь fs3 = 2.0)
    fdiv.s fs2, fs0, fs3    # Вычисляем начальное приближение: fs2 = a / 2.0 (x₀ = a/2)
    
    # Начало итерационного цикла метода Ньютона
    sqrt_loop:
        # Вычисление следующего приближения по формуле Ньютона:
        # x_{n+1} = 0.5 * (x_n + a / x_n)
        
        # a / x_n (деление исходного числа на текущее приближение)
        fdiv.s ft0, fs0, fs2    # ft0 = a / x_n (a - исходное число, x_n - текущее приближение)
        
        # x_n + a / x_n (сумма текущего приближения и отношения)
        fadd.s ft0, fs2, ft0    # ft0 = x_n + (a / x_n)
        
        # 0.5 * (x_n + a / x_n) (усреднение - получаем новое приближение)
        fdiv.s ft0, ft0, fs3    # ft0 = (x_n + a/x_n) / 2 = x_{n+1} (новое приближение)
        
        # Проверка точности: |x_{n+1} - x_n| < ε (достигли ли требуемой точности?)
        fsub.s ft1, ft0, fs2    # Вычисляем разность: ft1 = x_{n+1} - x_n (новое - старое)
        
        # Модуль разности (абсолютное значение)
        fabs.s ft1, ft1         # ft1 = |x_{n+1} - x_n| (берем модуль разности)
        
        # Если |разность| < точности, выходим из цикла
        flt.s t1, ft1, fs1      # Сравниваем: если |разность| < ε, то t1 = 1, иначе t1 = 0
        bnez t1, sqrt_end       # Если t1 ≠ 0 (достигли требуемой точности), переходим к концу
        
        # Обновление текущего приближения (если точность еще не достигнута)
        fmv.s fs2, ft0          # Обновляем текущее приближение: x_n = x_{n+1}
        j sqrt_loop             # Переходим к следующей итерации цикла
    
    # Метка выхода из цикла (достигнута требуемая точность)
    sqrt_end:
        # Возврат результата (последнее вычисленное приближение)
        fmv.s fa0, fs2          # Копируем результат из fs2 в fa0 (fa0 - регистр для возврата значения)
        
        # Восстановление регистров из стека (эпилог функции)
        flw fs0, 16(sp)         # Восстанавливаем регистр fs0 из стека
        flw fs1, 12(sp)         # Восстанавливаем регистр fs1 из стека
        flw fs2, 8(sp)          # Восстанавливаем регистр fs2 из стека
        flw fs3, 4(sp)          # Восстанавливаем регистр fs3 из стека
        lw ra, 0(sp)            # Восстанавливаем адрес возврата из стека
        addi sp, sp, 20         # Освобождаем 20 байт в стеке (возвращаем указатель стека)
        
        ret                     # Возврат из подпрограммы (переход по адресу в ra)