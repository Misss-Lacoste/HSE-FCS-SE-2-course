# math.asm - модуль математических вычислений для работы с массивами
# Содержит подпрограммы для вычисления среднего и формирования массива B

.text


# Подпрограмма вычисления среднего арифметического массива
# Параметры: a0 - адрес массива, a1 - размер массива
# Возвращает: fa0 - среднее арифметическое (число с плавающей точкой)

calculate_avg:
    addi sp, sp, -20    #сохраняем регистры
    sw ra, 16(sp)
    sw s0, 12(sp)       # s0 - адрес массива
    sw s1, 8(sp)        # s1 - размер массива
    sw s2, 4(sp)        # s2 - счетчик i
    sw s3, 0(sp)        # s3 - сумма элементов
    
    mv s0, a0           # Сохраняем параметры
    mv s1, a1
    li s2, 0            # Инициализация счетчика i = 0
    li s3, 0            # Инициализация суммы sum = 0
    
sum_loop:
    bge s2, s1, sum_end # Условие выхода: i >= N
    
    lw t0, 0(s0)        # Загрузка array[i]
    add s3, s3, t0      # sum = sum + array[i]
    
    addi s0, s0, 4      # Следующий элемент массива
    addi s2, s2, 1      # Увеличение счетчика
    j sum_loop          # Продолжение цикла

sum_end:
    # Вычисление среднего арифметического: average = sum / N
    fcvt.s.w fa0, s3    # Преобразование суммы в float
    fcvt.s.w fa1, s1    # Преобразование размера в float
    fdiv.s fa0, fa0, fa1 # Деление: fa0 = sum / N
    
    lw s3, 0(sp)        # восстанавливаем регистры
    lw s2, 4(sp)  #dвосстанавливаем регистр в s2 (размер)
    lw s1, 8(sp) # восстанавливаем в регистр s1(адрес массива)
    lw s0, 12(sp) #восстанавливаем адрес возврата
    lw ra, 16(sp)
    addi sp, sp, 20
    ret


# Подпрограмма формирования массива B по условию задачи
# Условие: элементы массива A, которые больше среднего, заменяются на среднее
# Параметры: a0 - адрес массива A, a1 - адрес массива B,
#            a2 - размер массива, fa0 - среднее арифметическое

form_array_B:
    addi sp, sp, -24    #сохраняем регистры (включая float)
    sw ra, 20(sp)
    sw s0, 16(sp)       # s0 - адрес массива A
    sw s1, 12(sp)       # s1 - адрес массива B
    sw s2, 8(sp)        # s2 - размер массива
    sw s3, 4(sp)        # s3 - счетчик i
    fsw fs0, 0(sp)      # fs0 - среднее арифметическое
    
    mv s0, a0           # Сохраняем параметры
    mv s1, a1
    mv s2, a2
    fmv.s fs0, fa0      # Сохраняем среднее значение
    li s3, 0            # Инициализация счетчика i = 0
    
form_loop:
    bge s3, s2, form_end # Условие выхода: i >= N
    
    lw t0, 0(s0)        # Загрузка A[i]
    fcvt.s.w fa1, t0    # Преобразование A[i] в float для сравнения
    
    # Сравнение A[i] со средним арифметическим
    flt.s t1, fs0, fa1  # t1 = 1 если average < A[i] (A[i] > average)
    beqz t1, store_original # Если A[i] <= average, сохраняем оригинал
    
    # Если A[i] > average, заменяем на среднее значение
    fcvt.w.s t0, fs0    # Преобразуем average обратно в целое число
    j store_value

store_original:
    # Сохраняем оригинальное значение A[i]
    # t0 уже содержит A[i], поэтому ничего не меняем

store_value:
    sw t0, 0(s1)        # Сохраняем значение в B[i]
    
    addi s0, s0, 4      # Следующий элемент массива A
    addi s1, s1, 4      # Следующий элемент массива B
    addi s3, s3, 1      # Увеличение счетчика
    j form_loop         # Продолжение цикла

form_end:
    flw fs0, 0(sp)      #восстанавливаем регистры
    lw s3, 4(sp)
    lw s2, 8(sp)
    lw s1, 12(sp) #ВЫШЕ АНАЛОГИЧНЫЕ КОММЕНТАРИИ
    lw s0, 16(sp)
    lw ra, 20(sp)
    addi sp, sp, 24
    ret