# io.asm - модуль ввода-вывода для работы с консолью
# Содержит подпрограммы для ввода и вывода массивов

.data
# Сообщения и форматы для ввода-вывода
msg_element: .asciz "A["    # Начало приглашения для ввода элемента
msg_bracket: .asciz "] = "  # Окончание приглашения
msg_comma:   .asciz ", "    # Разделитель элементов при выводе
io_newline:  .asciz "\n"    # Символ новой строки

.text


# Подпрограмма ввода целого числа с консоли
# Параметры: a0 - адрес строки-приглашения для ввода
# Возвращает: a0 - введенное целое число
input_int:
    addi sp, sp, -4     #выделяем место в стеке
    sw ra, 0(sp)        # Сохраняем адрес возврата
    
    li a7, 4            # Вывод строки-приглашения
    ecall #выводим строку-приглашение
    li a7, 5            # Ввод целого числа
    ecall               # Результат в a0
    
    lw ra, 0(sp)        # восстанавливаем регистры
    addi sp, sp, 4 #освобождаем место в стеке
    ret
# Подпрограмма ввода массива с консоли
# Параметры: a0 - адрес массива, a1 - размер массива

input_array:
    addi sp, sp, -16    #cохраняем регистры
    sw ra, 12(sp) #адрес возврата
    sw s0, 8(sp)        # s0 - адрес массива
    sw s1, 4(sp)        # s1 - размер массива
    sw s2, 0(sp)        # s2 - счетчик i
    
    mv s0, a0           # Сохраняем параметры в сохраняемых регистрах
    mv s1, a1 #cохраняем размер массива в s1
    li s2, 0            # Инициализация счетчика i = 0
    
input_loop:
    bge s2, s1, input_end  # Условие выхода из цикла: i >= N
    
    # Вывод приглашения для ввода элемента "A[i] = "
    la a0, msg_element
    li a7, 4 #код сист вызова для вывода строки
    ecall
    mv a0, s2           #загружаем Текущий индекс
    li a7, 1
    ecall
    la a0, msg_bracket #загружаем индекс окончания сообщения
    li a7, 4
    ecall #вывоим скобочеу
    
    # Ввод элемента массива
    li a7, 5
    ecall
    sw a0, 0(s0)        # Сохраняем введенное значение в массив
    
    addi s0, s0, 4      # Переход к следующему элементу массива
    addi s2, s2, 1      # Увеличение счетчика
    j input_loop        # Продолжение цикла

input_end:
    lw s2, 0(sp)        #восстанавливаем регистры
    lw s1, 4(sp) # Восстанавливаем регистр s1 (размер массива)
    lw s0, 8(sp) # Восстанавливаем регистр s0 (адрес массива)
    lw ra, 12(sp) # Восстанавливаем адрес возврата
    addi sp, sp, 16 # Освобождаем место в стеке
    ret   # Возврат из подпрограммы


# Подпрограмма вывода массива в консоль
# Параметры: a0 - адрес массива, a1 - размер массива
# Формат вывода: [1, 2, 3, 4, 5]
print_array:
    addi sp, sp, -16    #сохраняем регистры
    sw ra, 12(sp) # Сохраняем адрес возврата
    sw s0, 8(sp)        # s0 - адрес массива
    sw s1, 4(sp)        # s1 - размер массива
    sw s2, 0(sp)        # s2 - счетчик i
    
    mv s0, a0 # Сохраняем адрес массива в s0
    mv s1, a1 # Сохраняем размер массива в s1
    li s2, 0            # Инициализация счетчика i = 0
    
    li a0, '['          # Вывод открывающей скобки
    li a7, 11
    ecall
    
print_loop:
    bge s2, s1, print_end  # Условие выхода: i >= N
    
    lw a0, 0(s0)        # Загрузка текущего элемента
    li a7, 1            # Вывод элемента
    ecall
    
    addi s2, s2, 1      # Увеличение счетчика
    bge s2, s1, no_comma # Если последний элемент - не выводим запятую
    
    la a0, msg_comma    # Вывод разделителя ", "
    li a7, 4
    ecall
    
no_comma:
    addi s0, s0, 4      # Переход к следующему элементу
    j print_loop        # Продолжение цикла

print_end:
    li a0, ']'          # Вывод закрывающей скобки
    li a7, 11
    ecall
    
    lw s2, 0(sp)        #восстанавливаем регистры
    lw s1, 4(sp) # Восстанавливаем регистр s1 (размер массива)
    lw s0, 8(sp) # Восстанавливаем регистр s0 (адрес массива)
    lw ra, 12(sp) # Восстанавливаем адрес возврата
    addi sp, sp, 16 # Восстанавливаем адрес возврата
    ret # Возврат из подпрограммы