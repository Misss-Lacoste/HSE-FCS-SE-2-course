# file_io.asm - модуль для работы с файлами

.data
msg_filename:    .asciz "Введите имя файла с данными: "
msg_success:     .asciz "Файл успешно прочитан. Размер: "
msg_file_error:  .asciz "Ошибка: файл не существует или поврежден!\n"
msg_reading:     .asciz "Чтение данных из файла...\n"
file_newline:    .asciz "\n"
filename:        .space 64  # Буфер для имени файла (64 байта)
file_buffer:     .space 256 # Буфер для чтения файла (256 байт)

.text
# Подпрограмма чтения массива из файла
# Параметры: a0 - адрес массива для заполнения
# Возвращает: a0 - размер массива, a1 - 0 при успехе, -1 при ошибке

read_from_file:
    addi sp, sp, -16    # Выделяем 16 байт в стеке (4 слова) для сохранения регистров
    sw ra, 12(sp)       # Сохраняем адрес возврата (return address) по смещению 12
    sw s0, 8(sp)        # Сохраняем s0 (адрес целевого массива) по смещению 8
    sw s1, 4(sp)        # Сохраняем s1 (дескриптор файла) по смещению 4
    sw s2, 0(sp)        # Сохраняем s2 (временное хранение) по смещению 0
    
    mv s0, a0           # Копируем адрес целевого массива из a0 в s0 (сохраняем параметр)
    
    # Ввод имени файла с клавиатуры
    la a0, msg_filename # Загружаем адрес сообщения "Введите имя файла..." в a0
    li a7, 4            # Загружаем код системного вызова для печати строки (4)
    ecall               # Вызываем систему - печатаем приглашение
    
    la a0, filename     # Загружаем адрес буфера для имени файла в a0
    li a1, 64           # Указываем максимальную длину вводимой строки (64 символа)
    li a7, 8            # Загружаем код системного вызова для ввода строки (8)
    ecall               # Вызываем систему - читаем имя файла в буфер filename
    
    # Убираем символ новой строки из конца имени файла
    la t0, filename     # Загружаем адрес начала буфера filename в t0
remove_newline:
    lb t1, 0(t0)        # Загружаем байт (символ) из текущей позиции буфера в t1
    beqz t1, open_file  # Если символ = 0 (конец строки), переходим к открытию файла
    li t2, 10           # Загружаем ASCII код символа новой строки ('\n') в t2
    beq t1, t2, found_newline # Если текущий символ = '\n', переходим к обработке
    addi t0, t0, 1      # Увеличиваем указатель на 1 байт (переходим к следующему символу)
    j remove_newline    # Возвращаемся к началу цикла
found_newline:
    sb zero, 0(t0)      # Заменяем символ '\n' на 0 (завершаем строку раньше)
    
open_file:
    # Вывод сообщения о начале чтения файла
    la a0, msg_reading  # Загружаем адрес сообщения "Чтение данных из файла..."
    li a7, 4            # Код для печати строки
    ecall               # Печатаем сообщение
    
    # Открываем файл для чтения
    la a0, filename     # Загружаем адрес имени файла в a0 (параметр для open)
    li a1, 0            # Устанавливаем флаги: 0 = только чтение (O_RDONLY)
    li a7, 1024         # Загружаем код системного вызова open (1024)
    ecall               # Вызываем систему - открываем файл, результат в a0 (дескриптор)
    
    # Проверяем успешность открытия файла
    blt a0, zero, file_error  # Если дескриптор < 0 (ошибка), переходим к обработке ошибки
    mv s1, a0           # Сохраняем дескриптор файла из a0 в s1
    
    # Читаем данные из файла в буфер
    mv a0, s1           # Загружаем дескриптор файла в a0 (первый параметр read)
    la a1, file_buffer  # Загружаем адрес буфера для чтения в a1 (второй параметр)
    li a2, 256          # Указываем максимальное количество байтов для чтения (256)
    li a7, 63           # Загружаем код системного вызова read (63)
    ecall               # Вызываем систему - читаем файл, результат в a0 (количество прочитанных байтов)
    
    # Проверяем успешность чтения
    blt a0, zero, close_and_error  # Если результат < 0 (ошибка), переходим к закрытию и ошибке
    mv s2, a0           # Сохраняем количество прочитанных байтов из a0 в s2
    
    # Закрываем файл после успешного чтения
    mv a0, s1           # Загружаем дескриптор файла в a0 (параметр для close)
    li a7, 57           # Загружаем код системного вызова close (57)
    ecall               # Вызываем систему - закрываем файл
    
    
    # Инициализация переменных для парсинга из буфера
    la t0, file_buffer  # Загружаем адрес начала буфера с данными в t0 (указатель)
    li t1, 0            # Инициализируем t1 = 0 (здесь будет размер массива)
    li t2, 0            # Инициализируем t2 = 0 (счетчик прочитанных элементов)
    li t3, 0            # Инициализируем t3 = 0 (текущее парсируемое число)
    
    # Пропускаем начальные пробельные символы
skip_initial_spaces:
    lb t4, 0(t0)        # Загружаем текущий символ из буфера в t4
    beqz t4, parse_done # Если символ = 0 (конец данных), выходим
    li t5, 32           # Загружаем ASCII код пробела (32) в t5
    beq t4, t5, skip_space # Если текущий символ - пробел, пропускаем его
    li t5, 10           # Загружаем ASCII код новой строки (10) в t5
    beq t4, t5, skip_space # Если текущий символ - новая строка, пропускаем
    li t5, 13           # Загружаем ASCII код возврата каретки (13) в t5
    beq t4, t5, skip_space # Если текущий символ - возврат каретки, пропускаем
    j parse_first_number # Нашли не пробельный символ - начинаем парсинг числа

skip_space:
    addi t0, t0, 1      # Увеличиваем указатель на 1 байт (пропускаем пробел)
    j skip_initial_spaces # Возвращаемся к проверке следующего символа

    # Парсим первое число (размер массива)
parse_first_number:
    lb t4, 0(t0)        # Загружаем текущий символ из буфера в t4
    beqz t4, parse_done # Если конец данных - выходим
    li t5, 32           # Загружаем код пробела для сравнения
    beq t4, t5, finish_first_number # Если пробел - заканчиваем парсинг числа
    li t5, 10           # Загружаем код новой строки для сравнения
    beq t4, t5, finish_first_number # Если новая строка - заканчиваем парсинг
    
    # Проверяем, является ли символ цифрой (ASCII '0'-'9')
    li t5, 48           # Загружаем ASCII код '0' (48)
    blt t4, t5, finish_first_number # Если символ < '0' - не цифра, заканчиваем
    li t5, 57           # Загружаем ASCII код '9' (57)
    bgt t4, t5, finish_first_number # Если символ > '9' - не цифра, заканчиваем
    
    # Преобразуем цифру ASCII в числовое значение
    addi t4, t4, -48    # Вычитаем 48 из ASCII кода: '0'→0, '1'→1 и так дальше
    li t5, 10           # Загружаем 10 для умножения
    mul t1, t1, t5      # Умножаем текущее число на 10: t1 = t1 * 10
    add t1, t1, t4      # Добавляем новую цифру: t1 = t1 + цифра
    
    addi t0, t0, 1      # Переходим к следующему символу в буфере
    j parse_first_number # Продолжаем парсинг числа

finish_first_number:
    # Проверяем корректность размера массива
    li t5, 1            # Загружаем минимальный размер (1)
    li t6, 10           # Загружаем максимальный размер (10)
    blt t1, t5, file_error # Если размер < 1 - ошибка
    bgt t1, t6, file_error # Если размер > 10 - ошибка
    
    mv a0, t1           # Сохраняем размер массива в a0 для возврата
    
    # Читаем элементы массива
    li t2, 0            # Инициализируем счетчик элементов = 0
read_elements:
    bge t2, t1, read_success # Если прочитали все элементы (t2 >= t1), переходим к успеху
    
    # Пропускаем пробелы между числами
skip_spaces_loop:
    lb t4, 0(t0)        # Загружаем текущий символ
    beqz t4, read_success # Если конец данных - выходим
    li t5, 32           # Код пробела
    beq t4, t5, skip_char # Если пробел - пропускаем
    li t5, 10           # Код новой строки
    beq t4, t5, skip_char # Если новая строка - пропускаем
    li t5, 13           # Код возврата каретки
    beq t4, t5, skip_char # Если возврат каретки - пропускаем
    j parse_element     # Нашли начало числа - начинаем парсинг

skip_char:
    addi t0, t0, 1      # Пропускаем пробельный символ
    j skip_spaces_loop  # Продолжаем поиск числа

parse_element:
    li t3, 0            # Обнуляем текущее число (t3 = 0)
parse_digit_loop:
    lb t4, 0(t0)        # Загружаем текущий символ
    beqz t4, store_element # Если конец данных - сохраняем элемент
    li t5, 32           # Код пробела
    beq t4, t5, store_element # Если пробел - сохраняем элемент
    li t5, 10           # Код новой строки
    beq t4, t5, store_element # Если новая строка - сохраняем элемент
    li t5, 13           # Код возврата каретки
    beq t4, t5, store_element # Если возврат каретки - сохраняем элемент
    
    # Проверяем цифру
    li t5, 48           # '0'
    blt t4, t5, store_element # Если не цифра - сохраняем элемент
    li t5, 57           # '9'
    bgt t4, t5, store_element # Если не цифра - сохраняем элемент
    
    # Преобразуем цифру ASCII в число
    addi t4, t4, -48    # ASCII → число
    li t5, 10           # Загружаем 10 для умножения
    mul t3, t3, t5      # t3 = t3 * 10 (сдвигаем разряды)
    add t3, t3, t4      # t3 = t3 + новая_цифра
    
    addi t0, t0, 1      # Переходим к следующему символу
    j parse_digit_loop  # Продолжаем парсинг числа

store_element:
    sw t3, 0(s0)        # Сохраняем элемент в целевой массив по адресу s0
    addi s0, s0, 4      # Увеличиваем указатель массива на 4 байта (следующий int)
    addi t2, t2, 1      # Увеличиваем счетчик элементов на 1
    j read_elements     # Переходим к чтению следующего элемента

read_success:
    # Вывод сообщения об успешном чтении
    la a0, msg_success  # Загружаем адрес сообщения об успехе
    li a7, 4            # Код печати строки
    ecall               # Печатаем "Файл успешно прочитан. Размер: "
    mv a0, t1           # Загружаем размер массива для вывода
    li a7, 1            # Код печати целого числа
    ecall               # Печатаем размер массива
    la a0, file_newline # Загружаем адрес символа новой строки
    li a7, 4            # Код печати строки
    ecall               # Печатаем новую строку
    
    mv a0, t1           # Возвращаем размер массива в a0
    li a1, 0            # Устанавливаем код успеха (0) в a1
    j read_end          # Переходим к завершению подпрограммы

close_and_error:
    # Закрываем файл при ошибке чтения
    mv a0, s1           # Загружаем дескриптор файла
    li a7, 57           # Код системного вызова close
    ecall               # Закрываем файл

file_error:
    # Вывод сообщения об ошибке
    la a0, msg_file_error # Загружаем адрес сообщения об ошибке
    li a7, 4            # Код печати строки
    ecall               # Печатаем сообщение об ошибке
    li a0, 0            # Возвращаем размер 0 при ошибке
    li a1, -1           # Устанавливаем код ошибки (-1) в a1

parse_done:
read_end:
    # Эпилог - восстанавливаем регистры и освобождаем стек
    lw s2, 0(sp)        # Восстанавливаем s2 из стека
    lw s1, 4(sp)        # Восстанавливаем s1 из стека
    lw s0, 8(sp)        # Восстанавливаем s0 из стека
    lw ra, 12(sp)       # Восстанавливаем адрес возврата из стека
    addi sp, sp, 16     # Освобождаем 16 байт в стеке
    ret                 # Возвращаемся в вызывающую программу