#### Signals
После выдачи запроса ввода-вывода у процессора существует два способа узнать о том, что обработка запроса устройством завершена.
__Первый способ__ заключается в регулярной проверке процессором бита занятости в регистре состояния контроллера соответствующего
устройства – __polling__.
При __втором способе__ процессор имеет специальный вход, на который устройства ввода-вывода выставляют сигнал запроса прерывания -
__interrupt request__. При наличии такого сигнала процессор после выполнения текущей команды не выполняет следующую, а, сохранив
состояние ряда регистров, переходит к выполнению команд, расположенных по некоторым фиксированным адресам.

#### Exception, software interrupt / trap
Аналогичный механизм часто используется при обработке исключительных ситуаций (exception), возникающих при выполнении команды процессором. Этим же механизмом часто пользуются и для реализации так называемых программных прерываний (software interrupt, trap). Как правило, обработку аппаратных прерываний от устройств ввода-вывода производит сама операционная система.
Обработка же исключительных ситуаций и некоторых программных прерываний вполне может быть возложена на пользовательский процесс через механизм сигналов.

#### Способы возникновения сигналов
С точки зрения пользователя получение процессом сигнала выглядит как возникновение прерывания.
Процесс может получить сигнал от:
1. hardware (при возникновении исключительной ситуации);
2. другого процесса, выполнившего системный вызов передачи сигнала ;
3. операционной системы (при наступлении некоторых событий);
4. терминала (при нажатии определенной комбинации клавиш);
5. системы управления заданиями (при выполнении команды kill).

#### Реакции процесса на сигнал
Существует три варианта реакции процесса на сигнал:
1. Принудительно проигнорировать сигнал.
2. Произвести обработку по умолчанию: проигнорировать, остановить процесс (перевести в состояние ожидания до получения другого
специального сигнала ), либо завершить работу с образованием core файла или без него.
3. Выполнить обработку сигнала, специфицированную пользователем. При системном вызове fork() все установленные реакции на сигналы
наследуется порожденным процессом. При системном вызове exec() сохраняются реакции только для тех сигналов, которые игнорировались или обрабатывались по умолчанию.

#### Примеры сигналов
[The link](https://www.geeksforgeeks.org/linux-unix/signal-handling-in-linux-through-the-signal-function/)

#### Иерархия процессов UNIX
Каждая группа процессов в системе получает собственный уникальный номер - `getpgid()`.
Для перевода процесса в другую группу процессов - `setpgid()`.
Каждый сеанс в системе также имеет собственный номер - `getsid()`.
`setsid()` - создание новой группы, состоящей только из процесса, который его выполнил.

#### Команда kill
Из всех источников сигнала пользователю доступны только два – команда `kill` и посылка сигнала процессу с помощью системного
вызова `kill()`.
`kill [-signal] [--] pid`
Команда kill предназначена для передачи сигнала процессу (ам). `pid` определяет процесс или процессы.
`signal` определяет тип сигнала, который должен быть доставлен.

#### Системный вызов `kill()`
```
#include <signal.h>
int kill(pid_t pid, int signal);
```

Аргумент `pid` описывает, кому посылается сигнал, а аргумент `sig` – какой сигнал посылается. Этот системный вызов умеет делать много разных вещей, в зависимости от значения аргументов:
1. Если pid > 0 и sig > 0, то сигнал номером sig (если позволяют 2привилегии) посылается процессу с идентификатором pid.
2. Если pid = 0, а sig > 0, то сигнал с номером sig посылается всем процессам в группе, к которой принадлежит посылающий
процесс.

#### Системный вызов signal ( )
Служит для изменения реакции процесса на какой-либо сигнал .
```
#include <signal.h>
void (*signal (int sig, void (*handler) (int)))(int);
```

функция `signal()`, возвращающая указатель на функцию с одним параметром типа int, которая ничего не возвращает, и имеющая два параметра: параметр sig типа int и параметр handler, служащий указателем на ничего не возвращающую функцию с одним
параметром типа int.
`sig` – это номер сигнала, обработку которого предстоит изменить.
`handler` описывает новый способ обработки сигнала – это может быть указатель на пользовательскую функцию – обработчик сигнала,
специальное значение `SIG_DFL` или специальное значение `SIG_IGN`. Cпециальное значение `SIG_IGN` используется для того, чтобы процесс игнорировал поступившие сигналы с номером `sig`, специальное значение `SIG_DFL` – для восстановления реакции процесса на этот сигнал по умолчанию.

#### Конструкция для пользовательской обработки сигнала SIGHUP
```
void *my_handler(int nsig) {
 <обработка сигнала>
}
int main() {
 ...
 (void)signal(SIGHUP, my_handler);
 ...
}
```
#### Основной недостаток сист вызова signal
__Низкая надежность__
1. Обработка сигнала пользовательской функцией выполняется только один раз, после чего автоматически восстанавливается
реакция на сигнал по умолчанию.
2. Мы можем выставить на критических участках реакцию "игнорировать сигнал " с последующим восстановлением предыдущей реакции, но если сигнал все-таки возникнет на критическом участке, то информация о его возникновении будет безвозвратно потеряна.
3. Невозможность определения количества сигналов одного и того же типа, поступивших процессу, пока он находился в состоянии готовность. Сигналы одного типа в очередь не ставятся!

#### SIGPIPE
__Что произойдет с процессом, если он, выполняя один из этих системных вызовов, получит какой-либо сигнал?__
• Если реакция на полученный сигнал была "игнорировать сигнал, то поведение процесса не изменится.
• Если реакция на полученный сигнал установлена по умолчанию и заключается в прекращении работы процесса, то процесс перейдет в состояние закончил исполнение.
• Если реакция процесса на сигнал заключается в выполнении пользовательской функции, то процесс выполнит эту функцию. Чтобы пришедший сигнал SIGPIPE не завершил работу нашего процесса по умолчанию, мы должны его обработать самостоятельно.
Проанализировав значение системной переменной errno на предмет совпадения со значением EPIPE, мы можем отличить возникновение сигнала SIGPIPE от других ошибочных ситуаций