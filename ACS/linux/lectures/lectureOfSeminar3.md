#### Syscalls getuid & getgid
Сисстемные вызовы getuid and getgid используются для определения идентификаторов пользователя, запустившего программу на исполнение, и идентификатора группы, к которой он относится.
Example1:
```
#include <unistd.h>
#include <stdio.h>
int main() {
uid_t uid = getuid();
gid_t gid = getgid();
printf("My uid = %d, my gid = %d\n", (int)uid, (int)gid);
return 0;
}
```

#### Syscalls getpid & getppid
Системный вызов getpid позволяет получить идентификатор текущего процесса.
Идентификатор родительского процесса для данного текущего процесса можно получить с использованием системного вызова getppid.
Example2: Программа вывода идентификаторов текущего и родительского процессов.
```
#include <unistd.h>
#include <stdio.h>
int main() {
pid_t pid = getpid();
pid_t ppid = getppid();
printf("My pid = %d, my ppid = %d\n", (int)pid, (int)ppid);
return 0;
}
```
#### Syscall fork
Служит для создания нового процесса.
Это единственный способ породить новый процесс после
инициализации ОС Linux. Порождаемый процесс является почти полной копией родительского.
__Меняются следующие параметры:__
• идентификатор процесса;
• идентификатор родительского процесса;
• время, оставшееся до получения сигнала SIGALRM;
• сигналы, ожидавшие доставки родительскому процессу, не будут доставляться порожденному процессу.

Fork вызывается один раз, а при успешной работе возвращается два раза (один раз в процессе-родителе и один раз в процессе-ребенке).
При успешном создании нового процесса в нем fork()вернет 0, а в родительском значение равное идентификатору процессаребенка. Исходя из этого каждый из двух процессов может осуществить свою идентификацию, определив, является он родителем или ребенком.

Example3: Рассмотрим программу, осуществляющую порождение процесса и осуществляющую вывод идентификаторов.

```
#include <unistd.h>
#include <stdio.h>
int main(){
pid_t pid, ppid, chpid;
int a = 0;
chpid = fork();
a = a+1;
pid = getpid();
ppid = getppid();
printf("My pid = %d, my ppid = %d, child pid = %d,
result = %d\n",(int)pid, (int)ppid, (int)chpid, a);
return 0;
}
```
__Примерное решение__
```
if(chpid == -1) {
    printf("Incorrect fork syscall\n");
} else if (chpid == 0) {
    printf("I am child. ");
    printf("My pid = %d, my parent is %d and I have no child\n",
    (int)pid, (int)ppid);
} else {
    printf("I am parent. ");
    printf("My pid = %d, my parent is %d, my child is %d\n",
    (int)pid, (int)ppid, (int)chpid);
}
```
#### exit() 
Завершает процесс любой из функций.
#### exec() 
Вызов exec() заменяет пользовательский контекст текущего процесса на содержимое некоторого исполняемого файла и устанавливает начальные значения регистров процессора (в том числе устанавливает программный счетчик на начало загружаемой программы).

#### Разделяемая память Posix
__Стандарт Posix.1__
Механизмы совместного использования областей памяти
для неродственных процессов:
1. Отображение файлов в память: файл открывается вызовом open, а его дескриптор используется при вызове mmap для отображения содержимого файла в адресное пространство процесса.
2. Объекты разделяемой памяти: функция shm_open открывает объект IPC с именем стандарта Posix, возвращая дескриптор, который может быть использован для отображения в адресное пространство процесса вызовом mmap. 

#### Функции shm_open и shm_unlink
Процесс получения доступа к объекту разделяемой памяти Posix выполняется в два этапа:
1. Вызов shm_open с именем IPC в качестве аргумента позволяет либо создать новый объект разделяемой памяти, либо открыть существующий.
2. Вызов mmap позволяет отобразить разделяемую память в адресное пространство вызвавшего процесса.

#### Прототип функции shm_open
```
#include <sys/mman.h>
int shm_open (const char *name, int oflag, mode_t mode);
```
• Возвращает дескриптор. В случае успешного завершения > 0, либо -1 в случае ошибки
• oflag: O_RDONLY либо O_RDWR и один из следующих: O_CREAT, O_EXCL, O_TRUNC
• mode задает биты разрешений доступа.

#### Прототип функции shm_unlink
* удаление объекта разделяемой памяти по его имени (сегмент разделяемой памяти будет существовать, пока не будет отключен от всех процессов);
• не выполняет никаких действий до тех пор, пока объект не будет закрыт всеми открывшими его процессами. Однако после вызова shm_unlink последующие вызовы open, mq_open и sem_open выполняться не будут.

#### Прототип функции mmap
mmap отображает в адресное пространство процесса файл или объект разделяемой памяти Posix.
```
#include <sys/mman.h>
void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);
```
Возвращает начальный адрес участка памяти в случае успешного завершения. MAP_FAILED – в случае ошибки addr может указывать начальный адрес участка памяти процесса, в который следует   отобразить содержимое дескриптора fd. Аргумент len задает длину отображаемого участка в байтах; участок может начинаться не с начала файла (или другого объекта), а с некоторого места, задаваемого аргументом offset. 