### Linux. Lecture
#### Основные операции над процессами Linux
1. `Fork` - системный вызов («вилка», «разветвление»),позволяет процессу-родителю, создавать новый, дочерний процесс. Оба этих процесса являются (почти) идентичными: потомок получает копии родительского стека, данных, кучи, копии родительских сегментов стека и текста.

2. `Exit(status)` — библиотечная функция (libc) завершает процесс, делая все его ресурсы (память, дескрипторы открытых файлов и т. д.) доступными для последующего перераспределения ядром. Аргумент status – целое число, которое определяет код завершения процесса. Родительский процесс может извлечь этот код с помощью системного вызова wait().

3. `Execve(pathname, argv , envp)` — системные вызов загружает в память процесса новую программу (расположенную в pathname, с аргументами argv и списком переменных среды еnvp). Текст существующей программы сбрасывается, а для новой программы заново создаются сегменты со стеком, данными и кучей. Эту операцию часто называют выполнением новой программы.

4. `wait(*status)` — системный вызов имеет два назначения. Во-первых, если работа потомка не была завершена путем вызова exit(), wait() приостанавливает выполнение родителя, пока не будет завершен один из его потомков. Во-вторых, код завершения потомка возвращается через аргумент функции wait().

#### Идентификаторы процессов в Linux
`PID` - уникальный идентификатор процесса. Это целое положительное число.

#### Синхронизация родительского и дочернего процессов
##### Системный вызов wait()

```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
```
Ждет, когда один из потомков прекратит работу и возвращает код его завершения через буфер, указанный в аргументе status. Возвращает идентификатор завершенного процесса или -1 в случае ошибки. При этом:
1) Если ни один из потомков вызывающего процесса еще не завершился, вызов блокируется до завершения. Если на момент вызова какой-либо потомок уже прекратил
работу, wait сразу же возвращает значение;
2) если параметр status не равен NULL, он указывает на целое число, описывающее подробности завершения потомка;
3) вызов wait возвращает идентификатор завершившегося дочернего процесса. К ошибке может привести, например, отсутствие у вызывающего процесса потомков. В этом случае errno присваивается значение ECHILD.

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main ( )
{
    pid_t child_pid;

    child_pid = fork();
    tf (child_pid == -1) {
    printf("... I can't have a baby :( ...\n");
    }

    else tf (child_pid == 0) {
    sleep (5);
    printf("!!! I AM ZOMBI # %d !!!\n", getpid());
    printf("??? MY NEW PARENT %d ???", (int)getpid());
    }

    else {
    printf("??? Where is my baby ???\n");
    exit (0);
    }
    return 0;
}
```
5. Вызов exec (execute) загружает и запускает другую программу, которая замещает текущий процесс. Новая программа начинает свое выполнение с функции main. Все файлы вызывающей программы остаются открытыми. Они являются доступными новой программе. Используется шесть различных вариантов функций exec:
```
#include <unistd.h>
int execl(char *name, char *arg0, ... /*NULL*/);
int execv(char *name, char *argv[]);
int execle(char *name, char *arg0, ... /*,NULL, char *envp[]*/);
int execve(char *name, char *arv[], char *envp[]);
int execlp(char *name, char *arg0, ... /*NULL*/);
int execvp(char *name, char *argv[]);
```
#### Замещение процесса функцией `exec`
Суффиксы `l, v, p, e` в именах функций определяют формат и объем
аргументов, а также каталоги, в которых нужно искать загружаемую
программу:
● `l` (список). Аргументы командной строки передаются в форме списка arg0, arg1.... argn, NULL. Эту форму используют, если количество аргументов известно;
● `v` (vector). Аргументы командной строки передаются в форме вектора argv[]. Отдельные аргументы адресуются через argv [0], argv [1]... argv [n]. Последний аргумент (argv[n]) должен быть указателем NULL;
● `p` (path). Обозначенный по имени файл ищется не только в текущем каталоге, но и в каталогах, определенных переменной среды PATH;
● `e` (окружение). Функция ожидает список переменных среды в виде вектора (envp[]) и не использует текущей среды.

#### Пример использования функции execl
```
// execl.c
// Программа, замещаемая другим процессом
#include <unistd.h>
#include <stdio.h>
int main(int argc, char *argv[]) {
    printf("Выполняется %s\n", argv[0]);
    execl("./hello","hello","Hello","World!", NULL);
    return 0;
}
```
#### Межпроцессное взаимодействие (IPC)
Межпроцессное взаимодействие (Inter-process communication, IPC) —
набор методов для обмена данными между потоками процессов. Процессы могут быть запущены как на одном и том же компьютере, так и на разных, соединенных сетью.

#### Параметры буферизации

* __Отсутствие буфера (нулевая емкость)__
процесс-передатчик всегда обязан ждать приема.
• __Буфер конечной емкости__         процесс-передатчик обязан ждать освобождения места вбуфере, если буфер заполнен.
• __Буфер неограниченной емкости (нереализуемо!)__
процесс-передатчик никогда не ждет.

#### Структурирование данных
* __Потоковая модель__
операции приема/передачи не интересуются содержимым данных и их происхождением, данные не структурируются.
• __Модель сообщений__
на передаваемые данные накладывается определенная структура.

#### Средства межпроцессного взаимодействия
- каналы
- сигналы
- очереди сообщений
- разделяемая память
- сокеты

#### Каналы
__Канал__ – средство связи стандартного вывода одного процесса со
стандартным вводом другого. Старейший из инструментов IPC, существующий приблизительно со времени появления самых ранних версий оперативной системы UNIX. Предоставляет одностороннее взаимодействие (half-duplex, полудуплексное) между процессами.
Процесс, создающий канал, порождает дочерний процесс. Дочерний процесс наследует открытый файловый дескриптор от родителя, формируя основу для коммуникации между родителем и потомком.
Далее два процесса взаимно согласуются, "закрывая" неиспользуемый конец канала. Например, если потомок выполняет передачу данных через канал обратно родителю. Реализуется через системные вызовы. Чтобы послать данные в канал – write().
Чтобы получить данные из канала – read().
##### Неименованный файл
__Неименованный канал__ – двусторонний однонаправленный
безымянный файл.
При создании канала формируется два дескриптора:
- дескриптор для передачи (записи) в канал;
- дескриптор для приема (чтения) из канала.
При порождении дочерних процессов файловые дескрипторы наследуются, что позволяет им взаимодействовать как с родительским процессом, так и между собой. Недостаток – отсутствие имени, поэтому могут использоваться для взаимодействия только между родственными процессами.
##### Именованные каналы(FIFO)
Именованные каналы имеют следующие особенности:
● Существуют в виде специального файлового устройства
в файловой системе;
● Через канал могут взаимодействовать процессы
различного происхождения;
● Именованный канал остается в файловой системе для
дальнейшего использования и после завершения
ввода/вывода.

#### Сигналы
__Сигнал__ – программное прерывание, которое посылаются процессу, когда случается некоторое событие. Могут посылаться процессу, если система обнаруживает программное событие (пользователь дает команду прервать или остановить выполнение, получен сигнал на завершение от другого процесса). Могут прийти от ядра ОС, когда возникает сбой аппаратных средств.
```
Номер    Значение                         Реакция по умолчанию
SIGABRT  Ненормальное                     Завершение (abort())
SIGALRM  Окончание кванта времени         Завершение
SIGBUS   Аппаратная ошибка                Завершение
SIGCHLD  Изменение состояния потомка      Игнорирование
SIGCONT  Продолжение прерванной программы Продолжение / игнорирование
SIGEMT   Аппаратная ошибка                Завершение
SIGFPE   Ошибка вычислений с плавающей запятой Завершение
SIGILL   Неразрешенная аппаратная команда Завершение
SIGINT   Прерывание с терминала           Завершение
SIGIO    Асинхронный ввод/вывод           Игнорирование
SIGKILL  Завершение программы             Завершение
SIGPIPE  Запись в канал без чтения        Завершение
SIGPWR   Сбой питания                     Игнорирование
SIGQUIT  Прерывание с клавиатуры          Завершение
SIGSEGV  Ошибка адресации                 Завершение
SIGSTOP  Остановка процесса               Остановка
SIGTTIN  Попытка чтения из фонового процесса Остановка
SIGTTOU  Попытка записи в фоновый процесс Остановка
SIGUSR1  Пользовательский сигнал          Завершение
SIGUSR2  Пользовательский сигнал          Завершение
SIGXCPU  Превышение лимита времени CPU    Завершение
SIGXFSZ  Превышение пространства памяти (4GB) Завершение
SIGURG   Срочное событие                  Игнорирование
SIGWINCH  Изменение размера окна          Игнорирование
```
Функция `raise()` позволяет посылать программные сигналы в
выполняемую программу.
```
#include <signal.h>
#include <stdio.h>

int main() {
    int a,b;
    printf("Число : ");
    scanf("%d",&a);
    printf("Разделить на : ");
    scanf("%d",&b);
    if(b==0) {
        printf("Намечается деление на ноль\n");
        // raise(SIGFPE);
        raise(SIGINT);
        return 31;
    } else {
        printf("Результат = %d\n",a/b);
    }
    return 0;
}
```
Функция `kill()`используется для передачи сигнала указанному
в ней процессу.

#### Очереди сообщений
Очередь сообщений – набор структурированных сообщений, которые
могут поступать из нескольких процессов (потоков) в общую очередь. Процессы с соответствующими разрешениями могут помещать
 ообщения в очередь.
● Процессы с другими соответствующими разрешениями могут извлекать их из очереди.
● Каждое сообщение представляет в общем случае некоторую структуры и каждому сообщению его отправителем присваивается приоритет.
● Для записи сообщения в очередь не требуется наличия ожидающего
его процесса. Это отличает очереди сообщений от программных каналов и FIFO, в которые нельзя произвести запись, пока не появится считывающий данные процесс.
#### Очереди сообщений POSIX
```
#include <fcntl.h> /* Постоянные вида O_* */
#include <sys/stat.h> /* Постоянные для mode */
#include <mqueue.h>
```
#### Разделяемая память
__Разделяемая память (Shared memory)__ – механизм
межпроцессного взаимодействия, обеспечивающий обмен данными между процессами непосредственно через адресное пространство оперативной памяти. Является самым быстрым методом взаимодействия при межпроцессорных обменах. Не использует взаимодействие через ядро ОС.
##### Функции языка C, используемы для работы с памятью:
* `shm_open` — создание или подключение объекта разделяемой памяти POSIX по его имени;
* `shm_unlink` — удаление объекта разделяемой памяти по его имени
(сегмент разделяемой памяти будет существовать, пока не будет отключен от всех процессов);
* `ftruncate` — задаёт или изменяет размер разделяемой памяти (или
отображённого в память файла);
* `mmap` — подключает существующий или создаёт анонимный сегмент
разделяемой памяти к адресному пространству процесса.

#### POSIX: создание-удаление объекта памяти
```
#include <sys/mman.h>
#include <sys/stat.h> /* For mode constants */
#include <fcntl.h> /* For O_* constants */
int shm_open(const char *name, int oflag, mode_t mode);
int shm_unlink(const char *name);```
● name — имя объекта памяти (строка символов);
● oflag — флаги, задающие режим создания (O_RDONLY, O_RDWR,
O_CREAT, O_EXCL, O_TRUNC);
● mode — режим доступа (rwx).
shm_open возвращает дескриптор объекта памяти или -1 при ошибке.
shm_unlink возвращает 0 или -1 при невозможности удалить объект
памяти
```
#### POSIX: изменение размера объекта памяти
```
#include <unistd.h>
int ftruncate(int fd, off_t length);
```
● `fd` — дескриптор объекта памяти;
● `length` — размер выделяемой памяти.
Если размер памяти до этой операции был длиннее, то отсеченные данные теряются. Если размер был короче, то он увеличивается, а добавленная часть заполняется нулевыми байтами. Возвращает 0 при нормальном завершении или -1 при ошибке. Память должна быть открыта для записи.

#### POSIX: подключение к адресному пространству памяти
```
#include <sys/mman.h>
 void * mmap(void *start, size_t length, int prot ,
 int flags, int fd, off_t offset);
 ```
● `start` — дескриптор объекта памяти;
● `length` — размер выделяемой памяти;
● `prot` — желаемый режим защиты памяти (не должен конфликтовать с
режимом открытия файла);
● `flags` — тип отражаемого объекта;
● `fd` — дескриптор объекта памяти;
● `offset` — смещение.
Отражает length байтов, начиная со смещения offset файла (или другого объекта), определенного дескриптором fd, в память, начиная с адреса start. offset обычно = 0. Настоящее местоположение отраженных данных возвращается самой функцией mmap, и никогда не бывает равным 0.

#### POSIX: подключение к адресному пространству памяти
`prot`: является либо PROT_NONE либо побитовым ИЛИ одного или
нескольких флагов PROT_*.
● `PROT_EXEC` — данные в страницах могут исполняться;
● `PROT_READ` — данные можно читать;
● `PROT_WRITE` — в эту область можно записывать информацию;
● `PROT_NONE` — доступ к этой области памяти запрещен.
flags: задает тип отражаемого объекта, опции отражения и указывает, принадлежат ли отраженные данные только этому процессу или их могут читать другие. Cостоит из комбинации битов (приведены основные):
● `MAP_FIXED` — не использовать другой адрес, если адрес задан в
параметрах функции;
● `MAP_SHARED` — разделить использование отражения с другими
процессами, отражающими тот же объект;
● `MAP_PRIVATE` — создать неразделяемое отражение.
