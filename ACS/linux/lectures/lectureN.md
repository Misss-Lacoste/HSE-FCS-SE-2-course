### Linux. Lecture
#### Основные операции над процессами Linux
1. `Fork` - системный вызов («вилка», «разветвление»),позволяет процессу-родителю,
создавать новый, дочерний процесс. Оба этих процесса являются (почти) идентичными:
потомок получает копии родительского стека, данных, кучи, копии родительских
сегментов стека и текста.

2. `Exit(status)` - — библиотечная функция (libc) завершает процесс, делая все его ресурсы
(память, дескрипторы открытых файлов и т. д.) доступными для последующего
перераспределения ядром. Аргумент status – целое число, которое определяет код
завершения процесса. Родительский процесс может извлечь этот код с помощью
системного вызова wait().

3. `Execve(pathname, argv , envp)` — системные вызов загружает в память процесса
новую программу (расположенную в pathname, с аргументами argv и списком
переменных среды еnvp). Текст существующей программы сбрасывается, а для новой
программы заново создаются сегменты со стеком, данными и кучей. Эту операцию
часто называют выполнением новой программы.

4. `wait(*status)` — системный вызов имеет два назначения. Во-первых, если работа
потомка не была завершена путем вызова exit(), wait() приостанавливает выполнение
родителя, пока не будет завершен один из его потомков. Во-вторых, код завершения
потомка возвращается через аргумент функции wait().

#### Идентификаторы процессов в Linux
PID - уникальный идентификатор процесса. Это целое положительное число.

#### Синхронизация родительского и дочернего процессов
##### Системный вызов wait()

```
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
```
Ждет, когда один из потомков прекратит работу и возвращает код его завершения через
буфер, указанный в аргументе status. Возвращает идентификатор завершенного
процесса или -1 в случае ошибки. При этом:
1) Если ни один из потомков вызывающего процесса еще не завершился, вызов
блокируется до завершения. Если на момент вызова какой-либо потомок уже прекратил
работу, wait сразу же возвращает значение;
2) если параметр status не равен NULL, он указывает на целое число, описывающее
подробности завершения потомка;
3) вызов wait возвращает идентификатор завершившегося дочернего процесса.
К ошибке может привести, например, отсутствие у вызывающего процесса потомков.
В этом случае errno присваивается значение ECHILD.

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main ( )
{
    pid_t child_pid;

    child_pid = fork();
    tf (child_pid == -1) {
    printf("... I can't have a baby :( ...\n");
    }

    else tf (child_pid == 0) {
    sleep (5);
    printf("!!! I AM ZOMBI # %d !!!\n", getpid());
    printf("??? MY NEW PARENT %d ???", (int)getpid());
    }

    else {
    printf("??? Where is my baby ???\n");
    exit (0);
    }
    return 0;
}
```
5. Вызов exec (execute) загружает и запускает другую программу, которая
замещает текущий процесс. Новая программа начинает свое выполнение с
функции main. Все файлы вызывающей программы остаются открытыми. Они
являются доступными новой программе. Используется шесть различных
вариантов функций exec:
```
#include <unistd.h>
int execl(char *name, char *arg0, ... /*NULL*/);
int execv(char *name, char *argv[]);
int execle(char *name, char *arg0, ... /*,NULL, char *envp[]*/);
int execve(char *name, char *arv[], char *envp[]);
int execlp(char *name, char *arg0, ... /*NULL*/);
int execvp(char *name, char *argv[]);
```
#### Замещение процесса функцией `exec`
Суффиксы `l, v, p, e` в именах функций определяют формат и объем
аргументов, а также каталоги, в которых нужно искать загружаемую
программу:
● `l` (список). Аргументы командной строки передаются в форме списка
arg0, arg1.... argn, NULL. Эту форму используют, если количество
аргументов известно;
● `v` (vector). Аргументы командной строки передаются в форме вектора
argv[]. Отдельные аргументы адресуются через
argv [0], argv [1]... argv [n]. Последний аргумент (argv[n])
должен быть указателем NULL;
● `p` (path). Обозначенный по имени файл ищется не только в текущем
каталоге, но и в каталогах, определенных переменной среды PATH;
● `e` (окружение). Функция ожидает список переменных среды в виде вектора
(envp[]) и не использует текущей среды.

#### Пример использования функции execl
```
// execl.c
// Программа, замещаемая другим процессом
#include <unistd.h>
#include <stdio.h>
int main(int argc, char *argv[]) {
    printf("Выполняется %s\n", argv[0]);
    execl("./hello","hello","Hello","World!", NULL);
    return 0;
}
```
#### Межпроцессное взаимодействие (IPC)
Межпроцессное взаимодействие (Inter-process communication, IPC) —
набор методов для обмена данными между потоками процессов. Процессы
могут быть запущены как на одном и том же компьютере, так и на разных,
соединенных сетью.

#### Параметры буферизации

* __Отсутствие буфера (нулевая емкость)__
процесс-передатчик всегда обязан ждать приема
• __Буфер конечной емкости__         процесс-передатчик обязан ждать освобождения места в
буфере, если буфер заполнен
• __Буфер неограниченной емкости (нереализуемо!)__
процесс-передатчик никогда не ждет

#### Структурирование данных
* __Потоковая модель__
операции приема/передачи не интересуются
содержимым данных и их происхождением,
данные не структурируются
• __Модель сообщений__
на передаваемые данные накладывается
определенная структура

#### Средства межпроцессного взаимодействия
- каналы
- сигналы
- очереди сообщений
- разделяемая память
- сокеты



