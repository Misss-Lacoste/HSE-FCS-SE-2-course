### **Лекция 7: SQL DDL и DML - Архитектура данных и манипулирование состоянием**

## От `CREATE TABLE` до `MERGE`: строим и изменяем мир данных

---

## План на сегодня

1.  **DDL (Data Definition Language):**
    * **Фундамент - Типы данных:** Не просто `INT` и `VARCHAR`. Выбор типа как архитектурное решение.
    * **Встроенные функции:** Богатый инструментарий для работы с данными.
    *   **`CREATE TABLE`:** Проектирование контракта таблицы через ограничения (`constraints`).
    *   **`ALTER TABLE`:** Опасное искусство изменения "живой" схемы.
    *   **`DROP TABLE` и `TRUNCATE TABLE`:** В чем разница?
    * **Генераторы ключей:** SERIAL, IDENTITY, UUID - как правильно создавать уникальные идентификаторы.

2.  **DML (Data Manipulation Language):**
    *   **`INSERT`:** Создание новых строк/записей.
    *   **`UPDATE`:** Изменение существующих строк/записей.
    *   **`DELETE`:** Удаление строк/записей.

3.  **Синтез DDL и DML: Продвинутые операции**
    *   **`MERGE` (UPSERT):** Атомарное "создай или обнови".
    *   **`INSERT ... SELECT`:** Копирование и трансформация данных.

---

### **Часть 1: DDL (Data Definition Language) - Язык архитектора**

DDL - это команды, которыми мы описываем **структуру** нашей базы данных. Это не про данные, это про **контейнеры для данных**. Ошибки на этом уровне - самые дорогие.

#### **1.1 Фундамент - Типы данных: Больше, чем просто хранение**

Выбор типа данных - это не вопрос экономии пары байт. Это **первый и самый важный контракт целостности** для ваших данных.

| Категория              | Тип (Примеры PostgreSQL)                                                                             | Ключевые соображения и подводные камни                                                                                                                                                                                                                                                                                                                                                                                      |
| :--------------------- | :--------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Числовые**           | `SMALLINT`, `INTEGER`, `BIGINT`, `SERIAL` / `BIGSERIAL`, `NUMERIC(p, s)`, `REAL`, `DOUBLE PRECISION` | **Точность vs. Производительность:** `NUMERIC` абсолютно точен для финансовых расчетов (нет ошибок округления), но медленнее, чем `DOUBLE PRECISION` (числа с плавающей точкой). **Никогда не храните деньги в `FLOAT`/`DOUBLE`!** `SERIAL` - это не тип, а синтаксический сахар для автоинкрементного `INTEGER` с последовательностью (`sequence`).                                                                        |
| **Символьные**         | `CHAR(n)`, `VARCHAR(n)`, `TEXT`                                                                      | **`CHAR(n)`** всегда занимает `n` байт, дополняя пробелами. Используйте только для строк фиксированной длины (коды стран 'US', хеши 'md5'). **`VARCHAR(n)`** занимает реальную длину + overhead. `n` - это **ограничение**, а не выделение памяти. **`TEXT`** - для строк произвольной длины. В PostgreSQL `VARCHAR(n)` и `TEXT` работают практически одинаково по производительности, `n` - это просто `CHECK` constraint. |
| **Дата и время**       | `DATE`, `TIME`, `TIMESTAMP`, `TIMESTAMPTZ` (timestamp with time zone)                                | **Часовые пояса - это критично.** `TIMESTAMP` хранит "наивное" время (то, что вы вставили). `TIMESTAMPTZ` хранит момент времени в UTC, конвертируя его из часового пояса сессии при вставке и обратно при выборке. **Почти всегда используйте `TIMESTAMPTZ`** для любых глобальных данных, чтобы избежать неоднозначности.                                                                                                  |
| **Логические**         | `BOOLEAN`                                                                                            | Хранит `true`, `false` или `NULL` (трехзначная логика). Гораздо эффективнее и семантически правильнее, чем `INTEGER` 0/1.                                                                                                                                                                                                                                                                                                   |
| **Бинарные**           | `BYTEA`                                                                                              | Для хранения сырых бинарных данных (изображения, файлы), если нет возможности хранить их в S3 или другом файловом хранилище.                                                                                                                                                                                                                                                                                                |
| **Специализированные** | `UUID`, `JSON`/`JSONB`, `ARRAY`, `INET` (IP-адреса), `TSVECTOR` (полнотекстовый поиск)               | **`UUID`** - отличный выбор для первичных ключей в распределенных системах. **`JSONB`** - бинарная, индексируемая версия `JSON`. Позволяет эффективно запрашивать и индексировать вложенные структуры, стирая грань между реляционным и документным подходом.                                                                                                                                                               |

#### **1.2 Встроенные функции**

Встроенные функции позволяют выполнять сложные трансформации прямо на стороне базы, что часто гораздо эффективнее, чем извлекать "сырые" данные и обрабатывать их в приложении.

| Категория                      | Примеры функций (PostgreSQL)                                                                                               | Типичные сценарии использования                                                                                                                                                                                                                                                                                                                      |     |                                                                                                                                                                                                                           |
| :----------------------------- | :------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Строковые функции**          | `LENGTH()`, `LOWER()`, `UPPER()`, `TRIM()`, `SUBSTRING()`, `POSITION()`, `CONCAT()`, `COALESCE()`, `NULLIF()`              | **Очистка и нормализация:** `UPDATE users SET email = LOWER(TRIM(email));` <br> **Извлечение частей:** `SUBSTRING(fio FROM POSITION(' ' IN fio) + 1)` для получения имени. <br> **Безопасное объединение:** `CONCAT(first_name, ' ', last_name)` (в отличие от `                                                                                     |     | `, не возвращает `NULL`, если один из аргументов `NULL`). <br> **Работа с `NULL`:** `COALESCE(middle_name, 'N/A')` - вернуть первое не-NULL значение. `NULLIF(value, '')` - вернуть `NULL`, если `value` - пустая строка. |
| **Числовые функции**           | `ABS()`, `ROUND()`, `CEIL()`, `FLOOR()`, `RANDOM()`                                                                        | **Округление:** `ROUND(price * 1.2, 2)` для вычисления цены с НДС. <br> **Генерация случайных данных:** `ORDER BY RANDOM() LIMIT 10` для получения случайной выборки (неэффективно на больших таблицах!).                                                                                                                                            |     |                                                                                                                                                                                                                           |
| **Функции для даты и времени** | `NOW()`, `CURRENT_DATE`, `CURRENT_TIME`, `DATE_TRUNC('month', ...)` `EXTRACT(YEAR FROM ...)` `AGE(...)` `INTERVAL '1 day'` | **Фильтрация по периодам:** `WHERE created_at >= NOW() - INTERVAL '30 days'`. <br> **Группировка:** `GROUP BY DATE_TRUNC('week', registration_date)` для построения отчетов по неделям. <br> **Извлечение компонентов:** `EXTRACT(DOW FROM my_date)` для получения дня недели. <br> **Вычисления:** `AGE(birth_date)` для расчета текущего возраста. |     |                                                                                                                                                                                                                           |
| **Функции для `JSONB`**        | `->`, `->>`, `#>`, `@>`, `jsonb_build_object()`, `jsonb_agg()`                                                             | **Извлечение данных:** `my_json_column ->> 'name'` для получения значения поля `name` как текста. <br> **Проверка наличия:** `WHERE my_json_column @> '{"city": "Moscow"}'` - найти все записи, где JSON содержит указанный ключ-значение. <br> **Агрегация:** `jsonb_agg(my_row)` - собрать все строки в один JSON-массив.                          |     |                                                                                                                                                                                                                           |
| **Функции приведения типов**   | `CAST(column AS type)` или `column::type`                                                                                  | `CAST(total_sum AS NUMERIC(12,2))`. Особенно важно при делении целых чисел: `(5::NUMERIC / 2)` вернет `2.5`, а `(5 / 2)` вернет `2`.                                                                                                                                                                                                                 |     |                                                                                                                                                                                                                           |

> **Инженерный подход:** Прежде чем писать сложную логику обработки данных в приложении, всегда проверяйте, нет ли в вашей СУБД встроенной функции, которая делает это эффективнее.

#### **1.3 `CREATE TABLE`: Проектирование контракта**

Создание таблицы - это определение ее **контракта целостности** через `constraints`.

```sql
CREATE TABLE Employees (
    -- Определение колонок и их доменов
    EmployeeID      SERIAL PRIMARY KEY, -- SERIAL = INT + NOT NULL + UNIQUE + автоинкремент
    FIO             VARCHAR(255) NOT NULL,
    Email           VARCHAR(255) NOT NULL UNIQUE, -- Альтернативный ключ
    DepartmentID    INT,
    Salary          NUMERIC(10, 2) NOT NULL CHECK (Salary > 0), -- Ограничение-проверка
    HireDate        DATE NOT NULL DEFAULT CURRENT_DATE,

    -- Определение ограничений на уровне таблицы
    CONSTRAINT fk_department
        FOREIGN KEY (DepartmentID)
        REFERENCES Departments(DepartmentID)
        ON DELETE SET NULL -- Что делать при удалении связанного отдела
        ON UPDATE CASCADE  -- Что делать при обновлении ID связанного отдела
);
```

**Ключевые элементы контракта:**
*   `NOT NULL`: Гарантирует наличие значения.
*   `UNIQUE`: Гарантирует уникальность значения в столбце (для альтернативных ключей).
*   `PRIMARY KEY`: Комбинация `NOT NULL` и `UNIQUE`. Главный идентификатор.
*   `FOREIGN KEY`: Обеспечивает **ссылочную целостность**.
    *   `ON DELETE`: Поведение при удалении родительской записи.
        *   `RESTRICT` / `NO ACTION` (по умолчанию): Запретить удаление, если есть связанные записи.
        *   `CASCADE`: Удалить все связанные записи "каскадом". Опасно!
        *   `SET NULL`: Установить `NULL` в дочерних записях.
        *   `SET DEFAULT`: Установить значение по умолчанию.
    *   `ON UPDATE`: Поведение при изменении PK родительской записи (редкая операция).
*   `CHECK`: Любое произвольное логическое условие на значение в строке. `CHECK (EndDate > StartDate)`.
*   `DEFAULT`: Значение по умолчанию, если оно не указано при вставке.


**Отложенные ограничения (`DEFERRABLE`):**
**Проблема:** Иногда нужно временно нарушить ограничение внутри одной транзакции. Классический пример: поменять местами значения в столбце с `UNIQUE` ограничением.
`UPDATE my_table SET id = 2 WHERE id = 1;`
`UPDATE my_table SET id = 1 WHERE id = 2;` -- этот код упадет на первой строке из-за нарушения уникальности.
**Решение:** Сделать ограничение отложенным. Проверка будет выполнена не после каждого оператора, а **в момент `COMMIT`'а транзакции**.
``` sql
    CREATE TABLE Swappable (
        ID INT PRIMARY KEY DEFERRABLE INITIALLY DEFERRED
    );
    BEGIN;
    UPDATE Swappable SET ID = 2 WHERE ID = 1; -- OK
    UPDATE Swappable SET ID = 1 WHERE ID = 2; -- OK
    COMMIT; -- Проверка и фиксация
```

**Проверка на существование:**
В скриптах миграции вы не можете быть уверены, что объект еще не существует.
*   **Плохо (упадет при повторном запуске):** `CREATE TABLE Users (...);`
*   **Хорошо (идемпотентно):** `CREATE TABLE IF NOT EXISTS Users (...);`

Такой же подход используется для всех объектов схемы: `CREATE INDEX IF NOT EXISTS...`, `CREATE SCHEMA IF NOT EXISTS...`.

#### **1.4 `ALTER TABLE`: Хирургия на "живом" организме**

Изменение схемы работающей таблицы - одна из самых опасных операций в production.

*   `ADD COLUMN`: `ALTER TABLE Employees ADD COLUMN MiddleName VARCHAR(100);`
    *   **Проблема производительности:** В старых версиях СУБД это могло вызывать полную перестройку таблицы и долгие блокировки. В современных (как PostgreSQL) добавление nullable-колонки без `DEFAULT` - это мгновенная операция с метаданными. Добавление колонки с `DEFAULT` может потребовать перезаписи всей таблицы.
*   `DROP COLUMN`: `ALTER TABLE Employees DROP COLUMN MiddleName;`
    *   **Опасность:** Потеря данных необратима. Код приложения может быть еще не готов к отсутствию колонки.
*   `ALTER COLUMN / MODIFY COLUMN`: Изменение типа данных, `DEFAULT`, `NOT NULL`.
    *   `ALTER TABLE Employees ALTER COLUMN FIO TYPE VARCHAR(300);`
    *   **Проблема производительности:** Изменение типа данных почти всегда требует **полной перезаписи таблицы** и эксклюзивной блокировки, что приводит к простою.
*   `ADD/DROP CONSTRAINT`: `ALTER TABLE Employees ADD CONSTRAINT chk_salary_positive CHECK (Salary > 0);`
    *   Добавление `FOREIGN KEY` или `CHECK` может потребовать полного сканирования таблицы для проверки существующих данных.

> **Вывод для инженера:** Любой `ALTER TABLE` на большой таблице в production-системе должен рассматриваться как сложная операция, требующая планирования (миграции без простоя, см. лекцию про ORM).

#### **1.5 `DROP TABLE` vs `TRUNCATE TABLE`**

| Команда                    | Что делает                                       | Как это работает                                                     | Можно ли откатить?                             | Сработают ли триггеры? |
| :------------------------- | :----------------------------------------------- | :------------------------------------------------------------------- | :--------------------------------------------- | :--------------------- |
| `DELETE FROM my_table;`    | Удаляет все строки.                              | Выполняет N операций удаления (по одной на строку). Медленно.        | **Да** (в рамках транзакции).                  | **Да**.                |
| `TRUNCATE TABLE my_table;` | Удаляет все строки.                              | Пересоздает "пустую" таблицу или сбрасывает указатель. Очень быстро. | **Нет** (в большинстве СУБД это DDL-операция). | **Нет**.               |
| `DROP TABLE my_table;`     | Удаляет все строки **и саму структуру** таблицы. | Удаляет определение таблицы из словаря данных.                       | **Нет**.                                       | **Нет**.               |

#### **1.6 Объекты схемы, кроме таблиц**

База данных - это не только таблицы.
*   **`SCHEMA`:** Пространство имен для объектов БД. Позволяет логически группировать таблицы (`CREATE SCHEMA billing; CREATE TABLE billing.invoices(...);`) и управлять правами доступа.
*   **`VIEW`:** Виртуальная таблица, основанная на результате `SELECT`-запроса.
    *   **Сценарии:**
        1.  **Упрощение сложных запросов:** Спрятать сложный `JOIN` за простым представлением `CREATE VIEW user_orders AS SELECT ...`.
        2.  **Безопасность:** Дать пользователю доступ только к определенным столбцам и строкам (`CREATE VIEW public_users AS SELECT id, name FROM users WHERE is_public = true;`).
*   **`INDEX`:** Структура данных, которая обеспечивает быстрый поиск. Мы подробно разберем их в отдельной лекции, но создаются они через DDL. `CREATE INDEX idx_users_email ON Users(Email);`
*   **`SEQUENCE`:** Генератор чисел. `SERIAL` в PostgreSQL - это просто синтаксический сахар для `INTEGER` со `SEQUENCE`. Можно создавать их и вручную для более сложных сценариев.

**Генераторы ключей:**
Никогда не полагайтесь на ручной ввод или бизнес-логику для создания первичных ключей. Используйте встроенные механизмы СУБД.

| Метод                                 | Описание                                                                                                                                                  | Пример (PostgreSQL)                                                                  | Плюсы                                                                                                                                                                                                           | Минусы / Особенности                                                                                                                                 |
| :------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`SERIAL` / `BIGSERIAL`**            | **Синтаксический сахар.** Не настоящий тип данных, а короткая запись для создания целочисленной колонки, привязанной к **последовательности (sequence)**. | `UserID SERIAL PRIMARY KEY;`                                                         | Просто, интуитивно, стандарт "де-факто" для простых случаев.                                                                                                                                                    | Не является стандартом SQL. Последовательность - это отдельный объект, которым можно управлять. Номера могут иметь "пропуски" при откате транзакций. |
| **`IDENTITY` columns (Стандарт SQL)** | **Стандартный способ** создания автоинкрементных ключей, появившийся в SQL:2003. Более гибкий и декларативный, чем `SERIAL`.                              | `UserID INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY;`                               | Является стандартом SQL. Более строгий контроль (`ALWAYS` запрещает ручную вставку, `BY DEFAULT` - разрешает).                                                                                                  | Синтаксис может незначительно отличаться в разных СУБД.                                                                                              |
| **`UUID`**                            | **Универсальный уникальный идентификатор.** 128-битное число, генерируемое по алгоритму, который практически гарантирует глобальную уникальность.         | `UserID UUID PRIMARY KEY DEFAULT gen_random_uuid();` (требует расширения `pgcrypto`) | **Глобальная уникальность:** Идеально для распределенных систем, микросервисов, репликации. ID можно генерировать на стороне приложения, не дожидаясь ответа от БД. Не раскрывает порядок и количество записей. | Больше по размеру (16 байт против 4/8 у `INT`/`BIGINT`), что влияет на размер индексов. Может быть чуть медленнее при `JOIN`. Неудобен для человека. |

**Какой генератор выбрать?**
*   **Для простого монолитного приложения:** `SERIAL` / `BIGSERIAL` или `IDENTITY` - отличный выбор.
*   **Для микросервисной архитектуры, систем с оффлайн-режимом или где важна безопасность (нельзя "перебирать" ID в URL):** `UUID` - практически стандарт.

#### **1.7 Управление схемой как кодом**

*   **Анти-паттерн:** Заходить на production-сервер и писать `ALTER TABLE` в psql-консоли. Это невоспроизводимо, подвержено ошибкам и ведет к рассинхронизации сред (dev/staging/prod).
*   **Правильный подход (Infrastructure as Code):**
    1.  Все изменения схемы описываются в виде **миграционных скриптов** (например, `001_create_users_table.sql`, `002_add_email_to_users.sql`).
    2.  Эти скрипты хранятся в **системе контроля версий (Git)** вместе с кодом приложения.
    3.  Применение миграций автоматизируется с помощью специальных инструментов (**Flyway, Liquibase, Alembic**).
    *   Это гарантирует, что на любой среде можно воспроизвести нужную версию схемы и что все изменения проходят через code review.


---

### **Часть 2: DML (Data Manipulation Language) - Язык для работы с состоянием**

DML - это команды, которыми мы изменяем **содержимое** таблиц.

#### **2.1 `INSERT`: Создание новых строк**

```sql
-- Вставка одной строки с явным указанием колонок
INSERT INTO Employees (FIO, Email, DepartmentID, Salary)
VALUES ('Иванов Иван Иванович', 'ivanov@company.com', 10, 60000.00);

-- Вставка нескольких строк (более эффективно)
INSERT INTO Employees (FIO, Email, DepartmentID, Salary) VALUES
('Петров Петр Петрович', 'petrov@company.com', 10, 62000.00),
('Сидоров Сидор Сидорович', 'sidorov@company.com', 20, 70000.00);
```
 
 **`INSERT ... RETURNING`:**
**Проблема:** После вставки записи с `SERIAL` или `UUID` ключом, нам нужно получить этот сгенерированный ключ для дальнейшей работы в приложении.
**Наивное решение:** `INSERT ...; SELECT CURRVAL('my_seq');` - это два обращения к базе и не всегда безопасно в конкурентной среде.
**Правильное решение:** Использовать `RETURNING`, чтобы вернуть данные из вставленной строки за один запрос.

``` sql
    INSERT INTO Users (Name, Email)
    VALUES ('Новый Пользователь', 'new@user.com')
    RETURNING UserID, CreatedAt; -- Вернуть ID и время создания    
```

#### **2.2 `UPDATE`: Изменение существующих строк**

`UPDATE` **всегда** должен использоваться с `WHERE`. **Забытый `WHERE` в `UPDATE` или `DELETE` - одна из самых катастрофических ошибок, которую можно совершить.** Вариант защиты: сначала написать запрос `SELECT` с нужными условиями, посмотреть, что он вернул, а потом заменить `SELECT ...` на `UPDATE ... SET ...`. 

```sql
-- Обновить одну запись
UPDATE Employees
SET Salary = Salary * 1.1 -- Повысить зарплату на 10%
WHERE EmployeeID = 101;

-- Обновить несколько записей
UPDATE Employees
SET DepartmentID = 30
WHERE DepartmentID = 20; -- Перевести всех из отдела 20 в отдел 30
```
**`UPDATE ... FROM`:**
**Проблема:** Как обновить данные в одной таблице на основе агрегированных данных из другой?
**Решение:** `UPDATE` с `JOIN`-подобным синтаксисом.
    ```sql
    -- Обновить суммарное количество заказов для каждого клиента
    UPDATE Customers c
    SET TotalOrders = o.OrderCount
    FROM (
        SELECT CustomerID, COUNT(*) as OrderCount
        FROM Orders
        GROUP BY CustomerID
    ) AS o
    WHERE c.CustomerID = o.CustomerID;
    ```

#### **2.3 `DELETE`: Удаление существующих строк**

```sql
-- Удалить одну запись
DELETE FROM Employees
WHERE EmployeeID = 101;

-- Удалить несколько записей
DELETE FROM Employees
WHERE HireDate < '2010-01-01'; -- Уволить всех "старичков"
```

**Каскадное удаление (`ON DELETE CASCADE`):** Мощный, но опасный инструмент. Одно `DELETE` из таблицы `Users` может запустить цепную реакцию и удалить все заказы, комментарии, лайки и т.д. этого пользователя. Используйте с огромной осторожностью.

**"Мягкое" удаление (Soft Delete):**
**Идея:** Физически не удалять строки из базы, а лишь помечать их как удаленные.
**Реализация:**
1.  В таблицу добавляется nullable-столбец, например `DeletedAt TIMESTAMPTZ DEFAULT NULL`.
2.  Вместо `DELETE FROM Users WHERE UserID = 123;` выполняется `UPDATE Users SET DeletedAt = NOW() WHERE UserID = 123;`.
3.  Все `SELECT`-запросы в приложении должны быть модифицированы, чтобы всегда включать `... WHERE DeletedAt IS NULL`.
**Плюсы:** Сохранение истории, возможность легкого восстановления, сохранение ссылочной целостности.
**Минусы:** Усложнение запросов, "раздувание" таблиц, необходимость периодической архивации "удаленных" данных.

---
### **Часть 3: Продвинутые операции - Синтез DDL и DML**

#### **3.1 `INSERT ... SELECT`: Трансформация и копирование**

Эта конструкция позволяет вставлять в таблицу результаты `SELECT`-запроса.

*   **Сценарий:** Архивация старых заказов.
```sql
INSERT INTO OrdersArchive (OrderID, CustomerID, OrderDate, Amount)
SELECT OrderID, CustomerID, OrderDate, Amount
FROM Orders
WHERE OrderDate < '2020-01-01';
```

*   **Сценарий:** Создание агрегированной отчетной таблицы.
```sql
INSERT INTO MonthlySales (DepartmentID, Month, TotalSales)
SELECT
    DepartmentID,
    DATE_TRUNC('month', OrderDate),
    SUM(Amount)
FROM Orders o JOIN Employees e ON o.EmployeeID = e.EmployeeID
GROUP BY DepartmentID, DATE_TRUNC('month', OrderDate);
```

#### **3.2 `MERGE` (или `INSERT ... ON CONFLICT` в PostgreSQL) - UPSERT**

Это атомарная операция, которая решает классическую проблему "вставить, если не существует, или обновить, если существует".

**Проблема:** Как обновить счетчик просмотров для страницы за сегодня?
**Наивное решение (небезопасное):**
    1.  `SELECT ViewCount FROM DailyViews WHERE PageID = ? AND Date = ?`
    2.  Если запись найдена -> `UPDATE DailyViews SET ViewCount = ...`
    3.  Если не найдена -> `INSERT INTO DailyViews ...`
**Почему это плохо?** Между `SELECT` и `UPDATE`/`INSERT` может "вклиниться" другая параллельная транзакция. Это состояние гонки (`race condition`).

**Правильное решение (`MERGE`):**
   `MERGE` - стандарт SQL, но синтаксис сложный.
   `INSERT ... ON CONFLICT` - специфичная для PostgreSQL, но очень элегантная реализация. Эта операция **атомарна** и полностью защищена от состояний гонки. Она является краеугольным камнем для реализации многих ETL-процессов и систем, работающих с потоковыми данными.

```sql
-- Таблица со счетчиками
CREATE TABLE DailyPageViews (
    PageID      VARCHAR(255),
    ViewDate    DATE,
    ViewCount   INT NOT NULL,
    PRIMARY KEY (PageID, ViewDate) -- Ключ, по которому проверяется конфликт
);

-- Команда UPSERT
INSERT INTO DailyPageViews (PageID, ViewDate, ViewCount)
VALUES ('/home', '2023-10-27', 100) -- Вставляем новые данные
ON CONFLICT (PageID, ViewDate) -- Если строка с таким PK уже существует...
DO UPDATE
  -- ...то не вставляем, а обновляем существующую
  -- EXCLUDED - это специальная ссылка на данные, которые мы ПЫТАЛИСЬ вставить
  SET ViewCount = DailyPageViews.ViewCount + EXCLUDED.ViewCount;

