### **Лекция 9: База данных как экосистема - Абстракции, безопасность и автоматизация**
[[Лекция 9  - View Grant каталог хранимые процедуры]]
[[Лекция 4 - Нормализация]]
[[Лекция 5 - Высшие нормальные формы]]
[[Лекция 6 - SQL DDL DML]]
[[Лекция 7 - SQL SELECT]]
[[Лекция 8 - Сложный SQL]]
## План на сегодня

1.  **Уровни абстракции - `VIEW`:**
    *   **Обычные представления (`VIEW`):** Создание виртуальных таблиц для упрощения и безопасности.
    *   **CTE vs `VIEW`:** Когда использовать временную логику, а когда - постоянный объект?
    *   **Материализованные представления (`MATERIALIZED VIEW`):** Абстракция с кэшированием для высокой производительности.
2.  **Управление доступом - `GRANT` / `REVOKE`:**
    *   Модель безопасности PostgreSQL.
    *   Роли, привилегии, `OWNER`.
3.  **База данных как экосистема - Анатомия каталога:**
    *   **Объекты схемы:** `SCHEMA`, `TABLE`, `VIEW`, `INDEX`, `SEQUENCE`.
    *   **Типы данных как объекты:** `ENUM`, `TYPE`, `DOMAIN`.
    *   **Физическое хранение:** `DATABASE`, `TABLESPACE`.
    *   **Системный каталог (`information_schema`, `pg_catalog`):**  Как база данных знает о самой себе.
4.  **Активная логика в базе данных:**
    *   **Хранимые процедуры и функции:** Код внутри БД. Зачем это нужно?
    *   **Триггеры:** Автоматизация реакции на события. Мощь и опасность.

### **Часть 1: Уровни абстракции - `VIEW`**

До сих пор мы работали напрямую с таблицами. Но в реальных системах прямой доступ часто скрывают за слоем абстракции. `VIEW` (представление) - это основной инструмент для этого.

#### **1.1 Обычные представления (`VIEW`)**

`VIEW` - это именованный, сохраненный в базе данных `SELECT`-запрос, который ведет себя как виртуальная таблица.
*   **Виртуальная:** Данные физически не хранятся. Каждый раз, когда вы делаете `SELECT` из `VIEW`, СУБД "под капотом" выполняет `SELECT`-запрос, который определяет это `VIEW`.

**Зачем они нужны? Три главные причины:**

1.  **Упрощение сложных запросов:** Спрятать сложный `JOIN` или расчеты за простым именем.
    ```sql
    -- Сложный запрос для получения полной информации о заказах
    SELECT o.order_id, o.order_date, c.customer_name, SUM(oi.quantity * oi.price_per_unit) as total
    FROM Orders o
    JOIN Customers c ON o.customer_id = c.customer_id
    JOIN Order_Items oi ON o.order_id = oi.order_id
    GROUP BY o.order_id, c.customer_name;

    -- Создаем VIEW, чтобы спрятать эту сложность
    CREATE VIEW V_OrderSummaries AS
    SELECT o.order_id, o.order_date, c.customer_name, SUM(oi.quantity * oi.price_per_unit) as total
    FROM Orders o
    JOIN Customers c ON o.customer_id = c.customer_id
    JOIN Order_Items oi ON o.order_id = oi.order_id
    GROUP BY o.order_id, c.customer_name;

    -- Теперь аналитик может делать простой запрос
    SELECT * FROM V_OrderSummaries WHERE total > 1000;
    ```
2.  **Безопасность (Security):** Предоставить пользователям доступ не ко всей таблице, а только к определенным строкам или столбцам.
    ```sql
    -- В таблице Employees есть столбец 'salary'
    CREATE VIEW V_PublicEmployees AS
    SELECT employee_id, full_name, position FROM Employees WHERE is_active = true;

    -- Даем доступ к VIEW, а не к основной таблице
    GRANT SELECT ON V_PublicEmployees TO readonly_user;
    ```
3.  **Стабильный API для данных:** Вы можете провести рефакторинг базовых таблиц (например, разделить одну на две), но сохранить старый `VIEW`, который будет эмулировать прежнюю структуру. Это позволяет менять схему, не ломая код старых приложений.

#### **1.2 CTE vs `VIEW` - Ключевое различие для инженера**

| Характеристика | `WITH ... AS` (CTE) | `CREATE VIEW` |
| :--- | :--- | :--- |
| **Жизненный цикл** | Временный. Существует **только** на время выполнения одного запроса. | Постоянный. Хранится в базе данных как объект схемы. |
| **Назначение** | Инструмент для **написания запросов**. Улучшает читаемость и структурирует сложную логику. | Инструмент **проектирования схемы**. Создает постоянную абстракцию. |
| **Область видимости** | Локальная (один запрос). | Глобальная (вся база данных). |
| **Производительность** | Просто синтаксический сахар. Оптимизатор "встраивает" его в основной запрос. | Может влиять на производительность, так как оптимизатор не всегда может "сплющить" сложный VIEW. |

> **Правило:** Используйте `CTE`, чтобы сделать один конкретный запрос понятнее. Используйте `VIEW`, чтобы создать постоянный, переиспользуемый "фасад" для ваших данных.

#### **1.3 Материализованные представления (`MATERIALIZED VIEW`)**

Если `VIEW` основан на очень тяжелом запросе (агрегация миллиардов строк), то каждый `SELECT` из него будет очень медленным.
`MATERIALIZED VIEW` - это `VIEW` с **физическим кэшем**. Результат его `SELECT`-запроса сохраняется на диске как реальная таблица.
```sql
CREATE MATERIALIZED VIEW MV_MonthlySalesReport AS
SELECT
    DATE_TRUNC('month', sale_date) as sale_month,
    product_category,
    SUM(sale_amount) as total_sales,
    COUNT(*) as number_of_sales
FROM Sales
GROUP BY 1, 2;
```

*   **Чтение:** `SELECT * FROM MV_MonthlySalesReport;` - **мгновенное**, так как данные уже посчитаны и хранятся на диске.
*   **Главный компромисс:** Данные в материализованном представлении **устаревают**. Они не обновляются автоматически при изменении базовых таблиц.
*   **Обновление кэша:** Для обновления нужно вручную выполнить команду:
    ```sql
    REFRESH MATERIALIZED VIEW MV_MonthlySalesReport;
    ```
    Эта операция может быть долгой и блокирующей. Ее обычно запускают по расписанию (например, каждую ночь).

**Когда использовать?** Идеально для тяжелых, медленно меняющихся аналитических отчетов и дашбордов.
### **2. Управление доступом - `GRANT` / `REVOKE`**

Никто, кроме владельца и суперпользователя, не должен иметь полный доступ к данным. Управление доступом - основа безопасности БД.

**Модель безопасности PostgreSQL:**
*   **Субъект (кто?):** `ROLE` (Роль). В PostgreSQL и пользователь (`USER`), и группа (`GROUP`) - это просто разновидности `ROLE`.
*   **Объект (что?):** `TABLE`, `VIEW`, `SCHEMA`, `SEQUENCE`, `FUNCTION` и т.д.
*   **Действие (какое право?):** `PRIVILEGE` (Привилегия): `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`, `USAGE` (для схем и последовательностей), `EXECUTE` (для функций).

> **Лучшая практика:** Никогда не давайте права напрямую пользователям. Создавайте **роли**, давайте права ролям, а затем "включайте" пользователей в эти роли.

*   **`OWNER` (Владелец):** У каждого объекта в базе данных (таблицы, функции и т.д.) есть владелец - обычно это роль, которая выполнила команду `CREATE`.
    *   **Права владельца:** Владелец по умолчанию имеет **все** привилегии на объект и, что самое важное, только он (и суперпользователи) может выполнить `DROP` или `ALTER` для этого объекта.
    *   **Смена владельца:**
        ```sql
        -- Передать владение таблицей другой роли
        ALTER TABLE public.employees OWNER TO new_owner_role;
        ```
    *   В production-системах часто используют паттерн, когда есть отдельная роль-"мигратор" (`migration_role`), которая является владельцем всех таблиц. Приложение же работает под другой, менее привилегированной ролью (`app_role`), у которой есть только права `SELECT`, `INSERT`, `UPDATE`, `DELETE`, но не `ALTER` или `DROP`. Это защищает схему от случайных или злонамеренных изменений из кода приложения.

**Примеры:**
```sql
-- 1. Создаем роли
CREATE ROLE readonly;  -- Роль для тех, кто может только читать
CREATE ROLE data_analyst; -- Роль, которая наследует readonly и может создавать временные таблицы

-- 2. Назначаем привилегии ролям
-- Даем право подключаться к базе
GRANT CONNECT ON DATABASE my_database TO readonly;
-- Даем право использовать схему 'public' (без этого не будут видны таблицы)
GRANT USAGE ON SCHEMA public TO readonly;
-- Даем право ТОЛЬКО на чтение ВСЕХ таблиц в схеме
GRANT SELECT ON ALL TABLES IN SCHEMA public TO readonly;

-- Аналитик может делать все, что и readonly, плюс создавать временные таблицы
GRANT readonly TO data_analyst;
GRANT TEMP ON DATABASE my_database TO data_analyst;

-- 3. Создаем пользователя и назначаем ему роль
CREATE USER some_user WITH PASSWORD 'secure_password';
GRANT data_analyst TO some_user;
```
**`REVOKE`** - обратная операция: `REVOKE SELECT ON my_table FROM readonly_user;`

### **3. База данных как экосистема**

#### **3.1 Системный каталог: `information_schema`**
**Вопрос:** Откуда СУБД знает, какие таблицы, столбцы и ограничения существуют?
**Ответ:** Она хранит эту информацию в специальных системных таблицах - **системном каталоге**.

**`information_schema`** - это стандартный, кросс-платформенный набор `VIEW`, который предоставляет доступ к метаданным в режиме "только чтение". 

**Что можно узнать?**
```sql
-- Показать все таблицы и представления в текущей базе
SELECT table_name, table_type FROM information_schema.tables WHERE table_schema = 'public';

-- Показать все столбцы, их типы и могут ли они быть NULL для конкретной таблицы
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'employees';

-- Показать все ограничения (constraints)
SELECT constraint_name, constraint_type
FROM information_schema.table_constraints
WHERE table_name = 'employees';
```
**Иерархия объектов в PostgreSQL:**
`Кластер БД (Сервер)` -> `Базы данных` -> `Схемы` -> `Таблицы, Индексы, View, Функции и т.д.`

**Объекты схемы:**
*   **`SCHEMA`:** "Папка" для таблиц. Позволяет избежать конфликтов имен и управлять доступом. `CREATE SCHEMA billing; GRANT USAGE ON SCHEMA billing TO ...;`
*   **`TABLE`:** Основной объект хранения.
*   **`VIEW`:** Виртуальная таблица.
*   **`INDEX`:** Структура для ускорения поиска. Хотя индекс "привязан" к таблице, это **отдельный объект**, который занимает место на диске и требует обслуживания.
*   **`SEQUENCE`:** Отдельный объект-счетчик. Когда вы создаете `SERIAL`, PostgreSQL неявно создает для вас `SEQUENCE`.

#### **3.2 Типы данных как объекты схемы: `ENUM`, `TYPE`, `DOMAIN`**
Иногда стандартных типов данных недостаточно. PostgreSQL позволяет создавать свои.
*   **`CREATE TYPE ... AS ENUM` (Перечисление):**
    *   У вас есть столбец `status` со строго ограниченным набором значений ('pending', 'shipped', 'delivered'). Хранить их как `VARCHAR` небезопасно - можно опечататься.
    *   **Решение:** Создать собственный тип-перечисление.
    ```sql
    CREATE TYPE order_status AS ENUM ('pending', 'shipped', 'delivered');

    CREATE TABLE Orders (
        order_id SERIAL PRIMARY KEY,
        status order_status NOT NULL DEFAULT 'pending'
    );
    -- Теперь вставить что-либо, кроме этих трех значений, будет невозможно.
    -- Это гораздо эффективнее по хранению и надежнее, чем VARCHAR + CHECK.
    ```
*   **`CREATE TYPE ... AS ( ... )` (Составной тип):**
    *   Позволяет сгруппировать несколько полей в одну структуру, как `struct` в C. Используется реже, в основном в хранимых процедурах.
    ```sql
    CREATE TYPE full_address AS (
        city VARCHAR,
        street VARCHAR,
        zip_code VARCHAR
    );
    ```
*   **`CREATE DOMAIN` (Домен):**
    *   У вас есть несколько таблиц, где используется `email`. Везде нужно добавлять одно и то же ограничение `CHECK` на валидность.
    *   **Решение:** Создать **домен** - это базовый тип данных плюс набор ограничений.
    ```sql
    CREATE DOMAIN email_address AS VARCHAR(255)
        CHECK (VALUE ~ '^[A-Za-z0-9._%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$');

    CREATE TABLE Users (
        user_id SERIAL PRIMARY KEY,
        email email_address NOT NULL
    );
    CREATE TABLE Contacts (
        contact_id SERIAL PRIMARY KEY,
        email email_address
    );
    -- Теперь все столбцы типа email_address автоматически наследуют это ограничение.
    ```
#### **3.3 Физическое хранение: `DATABASE`, `TABLESPACE`**
*   **`DATABASE`:** База данных - это **изолированная** среда. Каждая сессия подключается к одной БД и может обращаться только к ее объектам (без специальных расширений типа `dblink`). У каждой БД свой системный каталог, свои пользователи (роли - общие для кластера) и свои настройки.
*   **`TABLESPACE` (Табличное пространство):**
    *   Это именованная **ссылка на директорию в файловой системе**, где PostgreSQL будет хранить файлы данных.
    *   **Сценарии использования:**
        1.  **Производительность:** Вынести самые "горячие" таблицы и их индексы на самые быстрые диски (SSD/NVMe), а архивные данные - на медленные, но объемные HDD.
        2.  **Управление местом:** Если на системном диске заканчивается место, можно создать новый `TABLESPACE` на другом диске и переместить туда часть данных.
    *   **Как это работает:**
    ```sql
    -- 1. Создаем tablespace, указывая путь в файловой системе
    -- (директория должна существовать и принадлежать пользователю postgres)
    CREATE TABLESPACE fast_disks LOCATION '/mnt/ssd_drive/pg_data';

    -- 2. При создании таблицы указываем, где ее хранить
    CREATE TABLE high_load_table (
        ...
    ) TABLESPACE fast_disks;

    -- 3. Индекс тоже можно разместить отдельно
    CREATE INDEX idx_hot_data ON another_table(some_column) TABLESPACE fast_disks;
    ```
    Это инструмент для администраторов баз данных (DBA), но для инженера важно знать о его существовании.
#### **3.4 Системный каталог: `information_schema` vs `pg_catalog`**

Мы уже знаем про `information_schema`. Но в PostgreSQL есть и другой, более мощный, но менее портируемый каталог.
*   **`information_schema`:**
    *   **Плюсы:** Стандарт SQL. Запросы будут работать (в основном) в MySQL, MS SQL и т.д.
    *   **Минусы:** Предоставляет ограниченную, высокоуровневую информацию. Не показывает специфичные для PostgreSQL детали (например, информацию о `TABLESPACE` или `TOAST`-таблицах).
*   **`pg_catalog`:**
    *   "Родной" системный каталог PostgreSQL. Это набор реальных таблиц (`pg_class`, `pg_attribute`, `pg_namespace`), которые хранят **всю** информацию о базе данных.
    *   **Плюсы:** Максимальная детализация. Можно узнать абсолютно все.
    *   **Минусы:** Нестандартный. Структура сложная, требует глубокого понимания внутреннего устройства PostgreSQL.
    *   **Пример (аналог запроса к `information_schema.columns`):**
        ```sql
        SELECT a.attname, format_type(a.atttypid, a.atttypmod)
        FROM pg_class c
        JOIN pg_attribute a ON a.attrelid = c.oid
        WHERE c.relname = 'employees' AND a.attnum > 0 AND NOT a.attisdropped;
        ```
    *   **Когда использовать?** Для написания инструментов администрирования, мониторинга или когда `information_schema` не дает нужной информации. `psql` команды (`\d`, `\dt`) работают именно с `pg_catalog`.
### **4. Активная логика в базе данных**

Иногда бизнеc-логику удобнее или эффективнее реализовать не в приложении, а внутри самой БД.
#### **4.1 Хранимые процедуры и функции**

Это именованный блок кода (написанный на PL/pgSQL, SQL, Python, и др.), который хранится и выполняется на сервере СУБД.

**Зачем?**
1.  **Инкапсуляция логики:** Спрятать сложный многошаговый расчет за одним вызовом функции. `SELECT calculate_user_rating(123);`
2.  **Уменьшение сетевого трафика:** Вместо того чтобы гонять сотни запросов из приложения, можно вызвать одну функцию, которая все сделает на сервере и вернет только финальный результат.
3.  **Переиспользование:** Одна и та же функция может использоваться разными приложениями, работающими с одной БД, гарантируя одинаковую бизнес-логику.

**Пример (PostgreSQL):**
```sql
CREATE OR REPLACE FUNCTION get_total_sales_by_employee(emp_id INT)
RETURNS NUMERIC AS $$
DECLARE
    total_sales NUMERIC;
BEGIN
    SELECT SUM(sale_amount) INTO total_sales
    FROM Sales
    WHERE employee_id = emp_id;
    RETURN total_sales;
END;
$$ LANGUAGE plpgsql;

-- Использование:
SELECT get_total_sales_by_employee(104);
```

#### **4.2 Триггеры**

Триггер - это хранимая процедура, которая **автоматически** запускается СУБД в ответ на DML-события (`INSERT`, `UPDATE`, `DELETE`) в указанной таблице.

**Зачем?** Для реализации логики, которая должна выполняться **всегда**, независимо от того, какое приложение меняет данные.
*   **Аудит:** Автоматически записывать все изменения в отдельную лог-таблицу.
*   **Сложные ограничения целостности:** Проверять условия, которые невозможно выразить через `CHECK` (например, "сумма позиций заказа должна совпадать с общей суммой в заказе").
*   **Денормализация:** Автоматически обновлять кэширующие поля (например, `total_orders` в таблице `Customers` при добавлении нового заказа).

**Пример: Аудит изменений зарплаты**
```sql
-- Таблица для логов
CREATE TABLE SalaryChangesLog (
    log_id SERIAL PRIMARY KEY,
    employee_id INT,
    old_salary NUMERIC,
    new_salary NUMERIC,
    changed_at TIMESTAMPTZ DEFAULT NOW()
);

-- Триггерная функция
CREATE OR REPLACE FUNCTION log_salary_change()
RETURNS TRIGGER AS $$
BEGIN
    -- OLD и NEW - специальные переменные, доступные в триггерах
    IF NEW.salary <> OLD.salary THEN
        INSERT INTO SalaryChangesLog (employee_id, old_salary, new_salary)
        VALUES (OLD.employee_id, OLD.salary, NEW.salary);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- "Привязываем" триггер к таблице
CREATE TRIGGER employees_salary_audit
BEFORE UPDATE ON Employees
FOR EACH ROW -- Триггер будет срабатывать для каждой измененной строки
EXECUTE FUNCTION log_salary_change();

-- Теперь любая команда UPDATE Employees SET salary = ... автоматически вызовет триггер.
```

> **Внимание! Опасность триггеров!**
> Триггеры создают **неявную логику ("магию")**. Когда вы делаете простой `UPDATE`, вы можете не подозревать, что за кулисами запускается сложная цепочка операций. Это делает код сложным для отладки и анализа.
> **Современный подход:** Бизнес-логике место в коде приложения (в сервисах, моделях), а триггеры используем только там, где это абсолютно необходимо для обеспечения целостности данных на самом низком уровне.


