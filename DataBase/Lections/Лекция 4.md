### **Лекция 4: Нормализация реляционных баз данных**

## Искусство проектирования "хороших" схем: от избыточности к порядку

---

## План на сегодня

1.  **Проблема:** Что такое "плохая" схема? Знакомство с **аномалиями данных**.
2.  **Диагностический инструмент:** Концепция **функциональной зависимости (ФЗ)**.
3.  **Пошаговое лечение (Нормальные формы):**
    *   **Первая нормальная форма (1НФ):** Борьба с хаосом.
    *   **Вторая нормальная форма (2НФ):** Устранение частичных зависимостей.
    *   **Третья нормальная форма (3НФ):** Устранение транзитивных зависимостей.
    *   **Нормальная форма Бойса-Кодда (НФБК/BCNF):** Усиленная версия 3НФ.
4.  **Прагматика:** Что такое **де-нормализация** и когда она оправдана?

---

### **1. Проблема: "Кошмарная таблица" и аномалии данных**

На прошлой лекции мы научились создавать формально корректные, целостные схемы. Но целостность - это еще не все. Давайте рассмотрим "плохую" таблицу, которая хранит заказы в интернет-магазине:

**`UnnormalizedOrders`**
(<u>OrderID</u>, <u>ProductID</u>, OrderDate, CustomerID, CustomerName, ProductDescription, ProductPrice, Quantity)

*Первичный ключ здесь составной: `(OrderID, ProductID)`.*

На первый взгляд, все данные на месте. Но при работе с этой таблицей мы столкнемся с тремя типами **аномалий**:

*   **Аномалия вставки (Insertion Anomaly):**
    *   **Проблема:** Мы не можем добавить в базу новый товар, который еще никто не заказывал, потому что для создания записи нам нужен `OrderID`, которого еще нет. Мы не можем добавить нового клиента, если он еще не сделал заказ.
    *   **Суть:** Таблица заставляет нас хранить разнородные факты (о заказах, о товарах, о клиентах) в одном месте.

*   **Аномалия удаления (Deletion Anomaly):**
    *   **Проблема:** Если клиент с ID=123 сделал всего один заказ на один товар, и мы удаляем этот заказ (например, он был отменен), то мы **теряем всю информацию о клиенте №123**, включая его имя.
    *   **Суть:** Удаление одного факта (о заказе) приводит к непреднамеренной потере другого факта (о клиенте).

*   **Аномалия обновления (Update Anomaly):**
    *   **Проблема:** Если `CustomerName` для клиента №123 изменится, нам придется найти и обновить **все строки**, относящиеся к заказам этого клиента. Если мы пропустим хотя бы одну, база данных станет противоречивой (у одного `CustomerID` будут разные `CustomerName`). То же самое с `ProductPrice`.
    *   **Суть:** Один и тот же факт хранится в нескольких местах, что порождает **избыточность данных (data redundancy)**.

**Нормализация - это формальный процесс декомпозиции (разделения) "плохих" таблиц на несколько "хороших", чтобы устранить избыточность и аномалии.**

---

### **2. Диагностический инструмент: Функциональная зависимость (ФЗ)**

Чтобы "лечить" схему, нам нужен способ описывать связи между данными. Этот способ - функциональная зависимость.

**Определение:** Атрибут `B` **функционально зависит** от атрибута `A` (обозначается `A → B`), если каждому значению `A` соответствует **в точности одно** значение `B`.

Проще говоря: **"Зная `A`, мы однозначно можем узнать `B`"**.

Давайте найдем ФЗ в нашей "кошмарной" таблице:
*   `OrderID → OrderDate` (Зная номер заказа, мы знаем его дату)
*   `OrderID → CustomerID`
*   `CustomerID → CustomerName`
*   `ProductID → ProductDescription, ProductPrice`
*   `(OrderID, ProductID) → Quantity` (Количество зависит от **полного** ключа)

**Ключевая идея нормализации - привести схему к такому виду, где все функциональные зависимости будут "правильными", то есть будут зависеть только от первичного ключа.**
#### **Аксиомы Армстронга: Правила вывода зависимостей**

Функциональные зависимости обладают свойствами, которые позволяют нам логически выводить новые зависимости из уже существующих. Эти свойства формализованы в виде аксиом Армстронга.

Пусть у нас есть отношение `R(A, B, C, ...)`:

1.  **Аксиома рефлексивности:** Если `B` является подмножеством `A`, то `A → B`.
    *   *Простыми словами:* Зная `(StudentID, Name)`, мы, очевидно, знаем `StudentID`. Это тривиальная зависимость.

2.  **Аксиома дополнения (Augmentation):** Если `A → B`, то `AC → BC`.
    *   *Простыми словами:* Если `StudentID → Name`, то, добавив `CourseID` к обеим частям, мы получим верную зависимость `(StudentID, CourseID) → (Name, CourseID)`.

3.  **Аксиома транзитивности:** Если `A → B` и `B → C`, то `A → C`.
    *   *Простыми словами:* Если `OrderID → CustomerID` и `CustomerID → CustomerAddress`, то `OrderID → CustomerAddress`. Это основа для поиска транзитивных зависимостей.

Из этих трех базовых аксиом можно вывести несколько полезных вторичных правил, например **правило декомпозиции** (если `A → BC`, то `A → B` и `A → C`) и **правило объединения** (если `A → B` и `A → C`, то `A → BC`).

**Зачем это нужно?** Аксиомы Армстронга - это математический фундамент, который позволяет анализировать полный набор зависимостей в схеме, а не только те, что очевидны.

### **Аналитический инструмент: Замыкание атрибутов и поиск ключей**

Как нам систематически найти **все** потенциальные ключи для отношения, зная только его атрибуты и ФЗ? Для этого используется алгоритм нахождения **замыкания множества атрибутов**.

**Определение:** **Замыкание** множества атрибутов `X` (обозначается `X+`) - это множество всех атрибутов, которые функционально определяются `X`.

**Алгоритм вычисления замыкания `X+`:**
1.  Начать с `result = X`.
2.  Циклически проходиться по всем данным ФЗ `A → B` в схеме.
3.  Если `A` является подмножеством `result`, то добавить `B` в `result`.
4.  Повторять шаг 3, пока `result` не перестанет меняться.

**Пример:**
*   Отношение: `R(A, B, C, D, E)`
*   Зависимости (F): `A → B`, `BC → D`, `E → A`
*   Найдем замыкание для `(E, C)`: `(EC)+`
    1. `result = {E, C}`
    2. Из `E → A`, добавляем `A`. `result = {E, C, A}`.
    3. Из `A → B`, добавляем `B`. `result = {E, C, A, B}`.
    4. Теперь у нас есть `{B, C}` в `result`. Из `BC → D`, добавляем `D`. `result = {E, C, A, B, D}`.
    5. `result` содержит все атрибуты отношения.

**Как это помогает найти ключи?**
*   **Свойство:** Множество атрибутов `X` является **суперключом**, если его замыкание `X+` содержит **все** атрибуты отношения.
*   **Свойство:** Множество атрибутов `X` является **потенциальным ключом**, если оно является суперключом, и ни одно его подмножество не является суперключом.

Используя этот алгоритм, мы можем систематически проверять различные комбинации атрибутов, чтобы найти все потенциальные ключи, а не угадывать их.

### **3. Пошаговое лечение: Нормальные формы**

Нормальные формы (НФ) - это последовательные шаги, каждый из которых устраняет определенный тип "неправильных" функциональных зависимостей.

#### **Первая нормальная форма (1НФ)**

*   **Цель:** Устранить хаос, обеспечить атомарность.
*   **Формальное требование:** Все атрибуты отношения должны быть **атомарными** (неделимыми). В ячейке таблицы не может быть списков, массивов или других составных структур.
*   **Простыми словами:** В каждой ячейке таблицы должно быть только одно значение. Никаких списков, массивов, JSON-объектов или перечислений через запятую.
*   **Пример нарушения:** Таблица, где в поле `Products` для одного заказа через запятую перечислены товары: `('101', 'Вася Пупкин', 'Лампа, Стол, Стул')`.

Это требование часто вызывает вопрос: **"А почему, собственно, нельзя? Чем так плох список телефонов в одной ячейке? Это же удобно!"**

Давайте разберемся на конкретном примере. Представим таблицу `Clients` с таким полем:

| ClientID | Name        | Phones                     |
| :------- | :---------- | :------------------------- |
| 101      | Иван Иванов | `89261112233, 84954445566` |
| 102      | Петр Петров | `89167778899`              |

На первый взгляд, все компактно. Но вот с какими проблемами мы неминуемо столкнемся:

**1. Проблемы с поиском и фильтрацией:**
*   **Задача:** "Найти всех клиентов, у которых есть телефон, начинающийся с `8916`".
*   **Решение с неатомарным полем:** Нам придется использовать медленные строковые операции (`LIKE '%8916%'`), которые не могут эффективно использовать индексы. А что если один телефон будет записан как `8(916)...`, а другой `+7916...`? 
*   **Решение с атомарным полем:** `SELECT * FROM ClientPhones WHERE Phone LIKE '8916%';` - это быстрая и точная операция по индексированному столбцу.

**2. Невозможность обеспечить уникальность и ссылочную целостность:**
*   **Задача:** "Убедиться, что один и тот же номер телефона не может быть присвоен двум разным клиентам".
*   **Решение с неатомарным полем:** Невозможно. СУБД не может заглянуть внутрь строки и проверить уникальность ее частей. Придется писать сложный и медленный код на стороне приложения.
*   **Решение с атомарным полем:** Простое ограничение `UNIQUE` на столбец `Phone`.
*   **Задача:** "Связать конкретный звонок из таблицы `Calls` с конкретным номером телефона клиента".
*   **Решение с неатомарным полем:** Невозможно создать внешний ключ (`FOREIGN KEY`), который ссылался бы на *часть* строки.

**3. Сложности с обновлением и удалением:**
*   **Задача:** "Удалить у Ивана Иванова рабочий телефон `84954445566`, оставив мобильный".
*   **Решение с неатомарным полем:** Нам нужно: 1) Прочитать всю строку. 2) Распарсить ее в приложении, удалив нужный кусок. 3) Собрать строку обратно. 4) Записать всю строку целиком. Это медленно, сложно и подвержено ошибкам.
*   **Решение с атомарным полем:** `DELETE FROM ClientPhones WHERE ClientID = 101 AND Phone = '84954445566';` - одна простая и атомарная (в смысле транзакции) операция.

**4. Ограничения на агрегацию и аналитику:**
*   **Задача:** "Посчитать, сколько всего телефонных номеров у нас в базе".
*   **Решение с неатомарным полем:** Снова сложный парсинг на стороне приложения.
*   **Решение с атомарным полем:** `SELECT COUNT(*) FROM ClientPhones;`.

> **Вывод:** Хранение неатомарных значений перекладывает всю работу по управлению данными с мощной, оптимизированной и надежной СУБД на код вашего приложения. Вы теряете главные преимущества реляционной модели: целостность данных, индексацию и мощный язык запросов SQL.

Еще один ключевой момент, который нужно понять: **атомарность - это не физическое свойство, а логическое, и оно зависит от бизнес-требований.**

Атрибут считается атомарным, если для **вашей конкретной задачи** нет необходимости обращаться к его составным частям.

Рассмотрим атрибут `Address`.

**Сценарий 1: Интернет-магазин, доставка курьером.**
*   **Требования:** Нам нужно печатать адрес на конверте/упаковке или передавать его курьеру. Нам не нужно искать всех клиентов из "города Москва" или с "улицы Ленина".
*   **Решение:** Для этой задачи строка `"119019, г. Москва, ул. Новый Арбат, д. 15, кв. 4"` **является атомарной**. Мы всегда работаем с ней как с единым целым. Хранить ее в одном поле `FullAddress` - это нормально и соответствует 1НФ.

**Сценарий 2: Аналитическая система для отдела маркетинга.**
*   **Требования:** Нам нужно строить отчеты: "Показать распределение клиентов по городам", "Найти всех клиентов из Московской области, но не из Москвы", "Проверить, на каких улицах у нас больше всего заказов".
*   **Решение:** Для этой задачи строка с адресом **не является атомарной**, потому что нам критически важен доступ к ее частям.
*   **Правильное проектирование:** Мы обязаны декомпозировать адрес на несколько атрибутов: `PostalCode`, `Region`, `City`, `Street`, `HouseNumber`, `ApartmentNumber`.

**Как принять решение? Задайте себе вопрос:** "Нужно ли мне когда-нибудь будет искать, фильтровать, сортировать, группировать или соединять данные по **части** этого атрибута?".

*   Если ответ **"Нет"** - атрибут для вас атомарен.
*   Если ответ **"Да"** - атрибут нужно декомпозировать.

**Состояние нашего примера:** В нашей таблице `UnnormalizedOrders` все атрибуты (`OrderID`, `ProductID`, `CustomerName` и т.д.) используются как единое целое. Поэтому мы можем считать, что она **уже находится в 1НФ**.
#### **Вторая нормальная форма (2НФ)**

*   **Цель:** Устранить зависимости от **части** составного ключа.
*   **Формальное требование:** Отношение находится в 2НФ, если оно находится в 1НФ и каждый неключевой атрибут **неприводимо (полностью) функционально зависит** от первичного ключа.
*   **Простыми словами:** Если у вас составной ключ, то все остальные столбцы должны зависеть от **всего ключа целиком**, а не от его части.
*   **Диагностика в нашем примере:**
    *   Первичный ключ: `(OrderID, ProductID)`.
    *   `OrderDate` и `CustomerID` зависят только от `OrderID` (части ключа).
    *   `ProductDescription` и `ProductPrice` зависят только от `ProductID` (части ключа).
    *   Это **частичные зависимости**. Они и вызывают аномалии.
*   **Лечение (Декомпозиция):** Мы "выносим" частичные зависимости в отдельные таблицы.

**`UnnormalizedOrders(OrderID, ProductID, ...)` →**

1.  **`Orders`**(<u>OrderID</u>, OrderDate, CustomerID, CustomerName)
2.  **`Products`**(<u>ProductID</u>, ProductDescription, ProductPrice)
3.  **`OrderItems`**(<u>OrderID (FK)</u>, <u>ProductID (FK)</u>, Quantity)

Мы избавились от частичных зависимостей. Теперь информация о товарах хранится в одном месте, информация о заказах - в другом. Аномалии вставки и удаления для товаров исчезли.

Обратите внимание, что если первичный ключ состоит из единственного столбца, то таблица автоматически соответствует 2НФ, можно даже не проверять.

#### **Третья нормальная форма (3НФ)**

*   **Цель:** Устранить зависимости между неключевыми атрибутами.
*   **Формальное требование:** Отношение находится в 3НФ, если оно находится в 2НФ и в нем отсутствуют **транзитивные функциональные зависимости** неключевых атрибутов от ключа.
*   **Простыми словами:** Неключевой столбец не должен зависеть от другого неключевого столбца.
*   **Диагностика в нашем примере:**
    *   Посмотрим на новую таблицу `Orders(OrderID, OrderDate, CustomerID, CustomerName)`.
    *   Здесь `OrderID` → `CustomerID` (ФЗ от ключа).
    *   Но также `CustomerID` → `CustomerName` (ФЗ между неключевыми атрибутами).
    *   Следовательно, `OrderID` → `CustomerID` → `CustomerName`. Это и есть **транзитивная зависимость**. Она вызывает аномалию обновления для данных клиента.
*   **Лечение (Декомпозиция):** "Выносим" транзитивную зависимость в свою таблицу.

**`Orders(OrderID, ...)` →**

1.  **`Customers`**(<u>CustomerID</u>, CustomerName)
2.  **`Orders_final`**(<u>OrderID</u>, OrderDate, CustomerID (FK))

**Итог после 3НФ:** Наша исходная "кошмарная" таблица превратилась в четыре "хорошие", нормализованные таблицы:
*   **`Customers`**(<u>CustomerID</u>, CustomerName)
*   **`Products`**(<u>ProductID</u>, ProductDescription, ProductPrice)
*   **`Orders`**(<u>OrderID</u>, OrderDate, CustomerID (FK))
*   **`OrderItems`**(<u>OrderID (FK)</u>, <u>ProductID (FK)</u>, Quantity)

> **Мнемоника для запоминания:** "Каждый неключевой атрибут должен предоставлять информацию о **ключе** (1НФ), **всем ключе** (2НФ) и **ни о чем, кроме ключа** (3НФ), да поможет мне Кодд".

#### **Нормальная форма Бойса-Кодда (НФБК / BCNF)**

*   **Цель:** Усиленная версия 3НФ, которая закрывает редкие аномалии, возможные в таблицах с несколькими пересекающимися составными потенциальными ключами.
*   **Формальное требование:** Отношение находится в BCNF, если для **каждой** нетривиальной функциональной зависимости `X → Y` детерминант `X` является **суперключом**.
*   **Простыми словами:** Левая часть **любой** функциональной зависимости должна быть как минимум потенциальным ключом.
*   **Когда 3НФ недостаточно?** Классический пример:
    *   `Enrollments(Student, Course, Professor)`
    *   Бизнес-правила:
        1.  Для каждого курса каждый студент может иметь только одного профессора. `(Student, Course) → Professor`.
        2.  Каждый профессор преподает только один курс. `Professor → Course`.
    *   Потенциальные ключи здесь: `(Student, Course)` и `(Student, Professor)`.
    *   Эта таблица в 3НФ, но зависимость `Professor → Course` нарушает BCNF, так как `Professor` - не суперключ. Это приводит к аномалиям.
*   **Лечение:** `(Student, Professor)` и `(Professor, Course)`.

**В 99% практических случаев хорошо спроектированная схема в 3НФ также будет и в BCNF.**

---
#### **Алгоритм синтеза схемы в 3НФ**

До сих пор мы занимались **декомпозицией**, брали плохую таблицу и делили ее. Но есть и другой подход. Мы можем с нуля построить "хорошую" схему, имея только список всех атрибутов и всех ФЗ.

**Входные данные:** Множество всех атрибутов `U` и множество всех ФЗ `F`.

**Шаги:**
1.  **Найти минимальное покрытие (Canonical Cover) `Fc` для `F`.** Это сложный шаг, который убирает избыточность из самих ФЗ (упрощает левые части, удаляет лишние зависимости). Для упрощения на практике мы работаем с исходным набором ФЗ.
2.  **Создать по одной таблице для каждой ФЗ.** Для каждой зависимости `A → B` из `Fc` создать таблицу со схемой `(A, B)`.
3.  **Сгруппировать таблицы.** Если несколько таблиц имеют одинаковую левую часть (одинаковый детерминант), объединить их. Например, из `A → B` и `A → C` получится одна таблица `(A, B, C)`.
4.  **Проверить наличие ключа.** Проверить, содержит ли хотя бы одна из созданных таблиц потенциальный ключ для исходного, большого отношения `U`.
5.  **Если ключ не найден:** Создать еще одну, дополнительную таблицу, состоящую только из атрибутов одного из потенциальных ключей исходного отношения `U`.

**Пример:**
*   Атрибуты: `(StudentID, StudentName, CourseID, CourseName, Grade)`
*   Зависимости: `StudentID → StudentName`, `CourseID → CourseName`, `(StudentID, CourseID) → Grade`
1.  (Пропускаем минимизацию для простоты).
2.  Создаем таблицы: `(StudentID, StudentName)`, `(CourseID, CourseName)`, `(StudentID, CourseID, Grade)`.
3.  (Группировать нечего).
4.  Потенциальный ключ для исходной схемы — `(StudentID, CourseID)`. Таблица `(StudentID, CourseID, Grade)` содержит этот ключ.
5.  Шаг 5 не требуется.

**Итог:** Мы **синтезировали** три таблицы, которые гарантированно находятся в 3НФ и сохраняют все исходные зависимости. Этот алгоритм лежит в основе многих CASE-средств для проектирования БД.

---

### **4. Прагматика: Де-нормализация для производительности**

**Нормализация - не самоцель.** Ее главная цель - устранение избыточности и аномалий. Но у нее есть "цена" - для получения полной картины нам приходится делать `JOIN`-ы между таблицами. В высоконагруженных системах `JOIN`-ы могут быть дорогими.

**Де-нормализация** - это **осознанный** и **контролируемый** процесс добавления избыточных данных в схему для повышения производительности чтения.

**Когда это оправдано?**

*   **Отчеты и аналитика (OLAP):** Для аналитических запросов часто создают специальные де-нормализованные "витрины данных", где все уже "сджойнено".
*   **Историчность данных:** В нашей нормализованной схеме в таблице `OrderItems` хранится только `ProductID`. Если цена на товар изменится в таблице `Products`, то "старые" заказы при `JOIN`-е покажут новую цену! Чтобы этого избежать, в `OrderItems` часто **денормализуют** `Price` на момент покупки: `OrderItems(OrderID, ProductID, Quantity, PriceAtPurchase)`.
*   **Кэширование:** Хранение часто запрашиваемых данных в де-нормализованном виде (например, имя автора вместе с названием поста).

> **Важно:** К де-нормализации приступают только после того, как есть нормализованная схема и **реальные** проблемы с производительностью, подтвержденные замерами. Это оптимизация, а не базовое проектирование.