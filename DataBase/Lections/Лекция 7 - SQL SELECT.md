### **SQL: Логика извлечения и агрегации данных**

## План на сегодня

1.  **Анатомия запроса:** Логический порядок выполнения операторов `SELECT`.
2.  **Cоединения:** Виды `JOIN`'ов.
3.  **Фильтрация до и после агрегации:** Разница между `WHERE` и `HAVING`.
4.  **Агрегатные функции и `GROUP BY`:** От плоских данных к сводным отчетам.
5.  **Подзапросы** и CTE.

### **1. Две реальности SQL-запроса: Логическая модель vs. Физический план выполнения**

Важно понимать, что SQL — это 
**декларативный** язык. Мы описываем **ЧТО** мы хотим получить, а не **КАК** это сделать. "Как" - это работа сложнейшего компонента СУБД, который называется **оптимизатор запросов**.

Поэтому у любого запроса есть две "реальности":
1.  **Логическая модель выполнения:** Это **концептуальная последовательность**, которая гарантирует семантически правильный результат. Мы используем ее как **ментальный инструмент**, чтобы рассуждать о запросе и понимать, почему синтаксис устроен именно так. **ЭТО НЕ ТО, КАК СУБД НА САМОМ ДЕЛЕ ВЫПОЛНЯЕТ ЗАПРОС.**
2.  **Физический план выполнения:** Это реальный алгоритм, который строит оптимизатор. Он может (и будет!) кардинально отличаться от логической модели: шаги могут быть переупорядочены, объединены, заменены на более эффективные аналоги или вовсе пропущены.

#### **1.1 Логическая модель выполнения запроса**

Чтобы писать корректные запросы, мы представляем себе, **"как если бы"** СУБД выполняла операции в следующем порядке. Эта модель позволяет нам понять область видимости псевдонимов, разницу между `WHERE` и `HAVING` и т.д.

**Логическая последовательность (концепция "as-if"):**
1.  **`FROM` / `JOIN`**: Формирование декартова произведения всех таблиц.
2.  **`WHERE`**: Фильтрация строк на основе предикатов.
3.  **`GROUP BY`**: Группировка отфильтрованных строк.
4.  **`HAVING`**: Фильтрация сгруппированных результатов.
5.  **`SELECT`**: Вычисление выражений, применение оконных функций.
6.  **`DISTINCT`**: Удаление дубликатов.
7.  **`ORDER BY`**: Сортировка финального набора.
8.  **`LIMIT` / `OFFSET`**: Пагинация.

Эта модель — наш контракт с СУБД. Мы пишем запрос, полагаясь на эту семантику, а СУБД **гарантирует**, что какой бы эффективный физический план она ни построила, результат будет **идентичен** тому, который получился бы при таком наивном последовательном выполнении.

#### **1.2 Физическая реальность: Что делает оптимизатор**

Оптимизатор — это мозг СУБД. Он анализирует ваш SQL-код, статистику данных (размеры таблиц, распределение значений), наличие индексов и генерирует оптимальный **план выполнения (execution plan)**.

Вот несколько примеров, как физическая реальность разрушает мифы наивной модели:

**Миф №1: "Коррелированный подзапрос — это всегда медленный цикл"**

Рассмотрим классическую задачу: "Найти всех сотрудников, работающих в отделах с объемом продаж выше 1 млн".

*   **Наивный коррелированный подзапрос:**
    ```sql
    SELECT E.Name FROM Employees E
    WHERE EXISTS (
        SELECT 1 FROM DepartmentSales DS
        WHERE DS.DepartmentID = E.DepartmentID AND DS.TotalSales > 1000000
    );
    ```
*   **Наивное "логическое" представление:** "Для каждого сотрудника из `Employees` выполнить внутренний запрос". Это `Nested Loops`, сложность O(N*M).
*   **Реальность оптимизатора:** Оптимизатор **никогда** не будет выполнять это в лоб на больших данных. Он "раскрутит" корреляцию и перепишет запрос в одну из форм **`SEMI-JOIN`'а**. Физически это может быть реализовано через:
    *   **Hash Join:** Сначала создается хэш-таблица из `DepartmentID` отделов-миллионников, а затем СУБД просто быстро проверяет для каждого сотрудника, есть ли его `DepartmentID` в этой хэш-таблице. Сложность близка к O(N+M).
    *   **Sort-Merge Join:** Если обе таблицы отсортированы по `DepartmentID`, СУБД может "слить" их за один проход.

**Миф №2: "`ORDER BY` — это всегда последняя операция сортировки"**

*   **Запрос:** `SELECT E.Name, D.DeptName FROM Employees E JOIN Departments D ON E.DepartmentID = D.DepartmentID ORDER BY D.DeptName;`
*   **Наивное представление:** "Сначала соединить, потом отсортировать".
*   **Реальность оптимизатора:**
    *   **Сценарий A (Index Scan):** Если по `Departments.DeptName` есть индекс, оптимизатор может решить, что дешевле сначала просканировать индекс `Departments` (данные уже будут отсортированы!), а затем для каждого названия отдела "подтягивать" сотрудников. `ORDER BY` выполняется "бесплатно".
    *   **Сценарий B (Sort-Merge Join):** Оптимизатор может решить использовать алгоритм `Sort-Merge Join`. Он сначала отсортирует обе таблицы по ключу соединения, а если этот ключ совпадает с ключом `ORDER BY` (или коррелирует с ним), то результат `JOIN`'а уже будет отсортирован. Финальный шаг сортировки не нужен.

**Миф №3: "`FROM` сначала строит огромное декартово произведение"**

*   **Наивное представление:** `FROM A, B, C` сначала создает таблицу размером `|A| x |B| x |C|`, а потом фильтрует.
*   **Реальность оптимизатора:** Оптимизатор анализирует условия `WHERE` и `JOIN`. Он никогда не будет материализовывать полное декартово произведение. Он выберет **оптимальный порядок соединений**. Например, сначала соединит маленькую таблицу `A` с `B` по очень селективному условию (чтобы получить маленький промежуточный результат), а уже потом соединит этот результат с большой таблицей `C`.

> **Главный вывод для инженера:** Логическая модель нужна, чтобы **писать корректные запросы**. Понимание физической реальности и работы оптимизатора нужно, чтобы **писать производительные запросы**. Вы должны уметь читать планы выполнения (`EXPLAIN ANALYZE`), чтобы понимать, какой из сотен возможных путей выбрал оптимизатор и почему ваш запрос работает быстро или медленно.

### **2. Cоединения (JOIN)**

Представим таблицы:
*   `Employees(EmployeeID, Name, DepartmentID)`
*   `Departments(DepartmentID, DeptName)`

1.  **`INNER JOIN`:**
    *   **Что делает?** Возвращает только те строки, для которых нашлось **совпадение в обеих таблицах** по условию соединения.
    *   **Аналогия:** Пересечение множеств.
    *   **Когда использовать?** Когда вам нужны данные, которые гарантированно связаны. "Показать всех сотрудников **и** названия их отделов". Сотрудники без отдела или отделы без сотрудников в результат не попадут.
    ```sql
    SELECT E.Name, D.DeptName
    FROM Employees E
    INNER JOIN Departments D ON E.DepartmentID = D.DepartmentID;
    ```
2.  **`LEFT JOIN` (или `LEFT OUTER JOIN`):**
    *   **Что делает?** Возвращает **все строки из левой таблицы** (той, что указана до `JOIN`) и совпавшие строки из правой. Если для строки из левой таблицы совпадения в правой не нашлось, столбцы из правой таблицы будут заполнены `NULL`.
    *   **Когда использовать?** Когда вам нужно сохранить все записи из основного набора, даже если для них нет связанных данных. "Показать **всех** сотрудников, и, если у них есть отдел, показать его название". Сотрудники без отдела останутся в списке, но с `NULL` в `DeptName`.
    ```sql
    SELECT E.Name, D.DeptName
    FROM Employees E
    LEFT JOIN Departments D ON E.DepartmentID = D.DepartmentID;
    ```
    *   **Ключевой трюк:** Поиск "сирот". "Найти всех сотрудников, которые **не** приписаны ни к одному существующему отделу".
    ```sql
    SELECT E.Name
    FROM Employees E
    LEFT JOIN Departments D ON E.DepartmentID = D.DepartmentID
    WHERE D.DepartmentID IS NULL; -- Фильтруем по отсутствию совпадения
    ```

3.  **`RIGHT JOIN` (или `RIGHT OUTER JOIN`):**
    *   **Что делает?** Зеркальная противоположность `LEFT JOIN`. Возвращает **все строки из правой таблицы** и совпавшие из левой.
    *   **Когда использовать?** Редко. Почти любой `RIGHT JOIN` можно переписать в более читаемый `LEFT JOIN`, поменяв таблицы местами. Но он полезен для поиска "сирот" с другой стороны. "Найти все отделы, в которых нет ни одного сотрудника".
    ```sql
    SELECT D.DeptName
    FROM Employees E
    RIGHT JOIN Departments D ON E.DepartmentID = D.DepartmentID
    WHERE E.EmployeeID IS NULL;
    ```

4.  **`FULL OUTER JOIN`**:
    *   **Что делает?** Возвращает **все строки из обеих таблиц**. Если совпадение есть, строки соединяются. Если нет, недостающая сторона заполняется `NULL`.
    *   **Когда использовать?** Для полного аудита данных. "Показать всех сотрудников и все отделы, чтобы выявить как сотрудников без отделов, так и отделы без сотрудников".

*   **`CROSS JOIN`**: Декартово произведение. "Соедини каждую строку из первой таблицы с каждой строкой из второй".
    *   **Ключевой сценарий:** Генерация данных. "Создать отчет, показывающий плановый KPI для каждого сотрудника на каждый месяц года".
    ```sql
    -- Months(MonthName) - простая таблица с 12 месяцами
    SELECT E.Name, M.MonthName, 10000 AS PlanKPI -- План 10000 для всех
    FROM Employees E
    CROSS JOIN Months M;
    ```
*   **Теоретико-множественные операции:**
    *   `UNION`: Объединяет результаты двух запросов, **удаляя дубликаты** (медленно).
    *   `UNION ALL`: Объединяет результаты, **оставляя все дубликаты** (очень быстро). Используйте его, если уверены в отсутствии дублей.
    *   `INTERSECT`: Возвращает только те строки, которые есть **в обоих** запросах.
    *   `EXCEPT`: Возвращает строки из первого запроса, которых **нет** во втором.
    *   **Сценарий:** "Найти всех клиентов из Москвы (`Customers_Moscow`) , которые при этом не являются VIP-клиентами (`VIP_Customers`)".
    ```sql
    SELECT CustomerID, Name FROM Customers_Moscow
    EXCEPT
    SELECT CustomerID, Name FROM VIP_Customers;
    ```
### **3. Фильтрация: `WHERE` vs `HAVING`**

Это одна из самых фундаментальных концепций в SQL, напрямую связанная с логическим порядком выполнения.

*   **`WHERE` — фильтр для сырых данных.**
    *   **Когда работает?** **ДО** группировки (`GROUP BY`).
    *   **С чем работает?** С отдельными строками.
    *   **Что может использовать?** Любые столбцы из таблиц, указанных в `FROM`. **Не может** использовать агрегатные функции (`SUM`, `COUNT` и т.д.), потому что они еще не вычислены.
    ```sql
    -- Выбрать заказы ДО 2023 года на сумму > 100
    SELECT CustomerID, SUM(Amount)
    FROM Orders
    WHERE Amount > 100 AND OrderDate < '2023-01-01' -- Фильтрация сырых строк
    GROUP BY CustomerID;
    ```

*   **`HAVING` — фильтр для агрегированных данных.**
    *   **Когда работает?** **ПОСЛЕ** группировки.
    *   **С чем работает?** С целыми группами строк, созданными `GROUP BY`.
    *   **Что может использовать?** Агрегатные функции и столбцы, по которым шла группировка. **Не может** использовать столбцы, не участвующие в агрегации или группировке, так как на этом этапе отдельных строк уже не существует.
    ```sql
    -- Найти клиентов, чья ОБЩАЯ сумма заказов > 1000
    SELECT CustomerID, SUM(Amount)
    FROM Orders
    GROUP BY CustomerID
    HAVING SUM(Amount) > 1000; -- Фильтрация групп по агрегированному результату
    ```
### **4. Агрегатные функции и `GROUP BY`**

Эти инструменты превращают "сырые" данные в осмысленную информацию.
*   **Агрегатные функции:** `COUNT()`, `SUM()`, `AVG()`, `MIN()`, `MAX()`.
    *   **Что делают?** Принимают на вход набор значений (столбец) и возвращают одно-единственное значение.
    *   `COUNT(*)`: Считает все строки.
    *   `COUNT(column)`: Считает строки, где `column` не `NULL`.
    *   `COUNT(DISTINCT column)`: Считает **уникальные** не-`NULL` значения.

*   **`GROUP BY`**:
    *   **Что делает?** Собирает все строки с одинаковыми значениями в указанных столбцах в одну "корзину" (группу).
    *   **Правило `GROUP BY`:** Если в вашем `SELECT` есть хотя бы одна агрегатная функция и хотя бы один обычный столбец, то **все** обычные столбцы **обязаны** быть перечислены в `GROUP BY`.
    *   **Почему?** Подумайте логически. Вы просите: "Покажи мне `DepartmentID` и `SUM(Salary)`". Если не сгруппировать по `DepartmentID`, СУБД не поймет, **какой именно** `DepartmentID` из всех сотрудников показать рядом с **общей** суммой зарплат по всей компании. `GROUP BY DepartmentID` говорит: "Для каждого `DepartmentID` посчитай свою сумму зарплат".
### **5. Подзапросы и CTE**

#### **Подзапросы**

*   **Скалярный подзапрос** (возвращает 1 строку, 1 столбец):
    *   Используется там, где ожидается одно значение.
    ```sql
    SELECT Name, Salary, (SELECT AVG(Salary) FROM Employees) AS AvgCompanySalary
    FROM Employees;
    ```
*   **Многострочный подзапрос** (возвращает 1 столбец, много строк):
    *   Используется с операторами `IN`, `ANY`, `ALL`.
    ```sql
    -- Найти все отделы, в которых есть сотрудники с зарплатой выше 100k
    SELECT DeptName FROM Departments
    WHERE DepartmentID IN (SELECT DepartmentID FROM Employees WHERE Salary > 100000);
    ```
*   **Коррелированный подзапрос:** Внутренний запрос, который зависит от внешнего. Выполняется **для каждой строки** внешнего запроса. **Очень медленный, избегайте его по возможности!**
    *   **Классическая задача:** "Найти всех сотрудников, получающих максимальную зарплату в своем отделе".
    ```sql
    SELECT e1.Name, e1.Salary, e1.DepartmentID
    FROM Employees e1
    WHERE e1.Salary = (SELECT MAX(e2.Salary)
                       FROM Employees e2
                       WHERE e2.DepartmentID = e1.DepartmentID); -- Корреляция
    ```
#### **Common Table Expressions (CTE) - именованные представления**

CTE (`WITH ... AS`) позволяет разбить сложный запрос на логические, читаемые шаги. Это как временные именованные таблицы, существующие только на время выполнения запроса.

*   **Цель:** Убрать пирамиду из вложенных подзапросов, улучшить читаемость и возможность повторного использования логики.
*   **Синтаксис:**
    ```sql
    WITH
      -- Шаг 1: Находим активных пользователей
      ActiveUsers AS (
        SELECT UserID FROM Orders WHERE OrderDate > '2023-01-01'
      ),
      -- Шаг 2: Считаем их заказы, ссылаясь на шаг 1
      UserOrderCounts AS (
        SELECT UserID, COUNT(*) as OrderCount
        FROM Orders
        WHERE UserID IN (SELECT UserID FROM ActiveUsers)
        GROUP BY UserID
      )
    -- Финальный запрос, использующий результаты шагов
    SELECT u.Name, uoc.OrderCount
    FROM Users u
    JOIN UserOrderCounts uoc ON u.UserID = uoc.UserID
    WHERE uoc.OrderCount > 5;
    ```
### **Рекурсивные CTE**

Как найти всех подчиненных конкретного менеджера на всю глубину иерархии одним запросом?

*   **Рекурсивные CTE** - это механизм для обхода иерархических или графовых структур.
*   **Структура:**
    1.  **Якорная часть:** Начальное условие, "корень" рекурсии.
    2.  `UNION ALL`.
    3.  **Рекурсивная часть:** Запрос, который ссылается на саму CTE, делая "шаг" по иерархии.
    4.  Условие остановки (в `WHERE` рекурсивной части).

*   **Задача:** "Найти всех сотрудников в подчинении у менеджера с `EmployeeID = 10`". (Таблица `Employees(EmployeeID, Name, ManagerID)`)

   ```sql
    WITH RECURSIVE Subordinates AS (
      -- 1. Якорь: Начинаем с прямых подчиненных менеджера 10
      SELECT EmployeeID, Name, ManagerID, 1 AS Level
      FROM Employees
      WHERE ManagerID = 10
      UNION ALL      -- 2. Рекурсия: Соединяем Employees с теми, кого мы уже нашли (Subordinates)
      SELECT e.EmployeeID, e.Name, e.ManagerID, s.Level + 1
      FROM Employees e
      JOIN Subordinates s ON e.ManagerID = s.EmployeeID -- Шаг вглубь
    )
    SELECT * FROM Subordinates;
    ```
