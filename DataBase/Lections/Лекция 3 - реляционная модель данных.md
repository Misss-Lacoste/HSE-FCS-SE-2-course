# **Лекция 3: Реляционная модель данных**

## От чертежа архитектора к плану инженера

---

## План на сегодня

1.  **Теоретический фундамент**
    *   Анатомия реляционной модели: отношения, кортежи, домены.
    *   **Иерархия ключей:** суперключ, потенциальный, первичный, альтернативный.
    *   **Ограничения целостности:** 4 столпа надежности данных.
2.  **Практический алгоритм**
    *   7 правил трансформации ER-диаграммы в реляционную схему.
3.  **Кейс:** Превращаем ER-диаграмму коворкинга в набор таблиц.
4.  **Что дальше?** Зачем нужна нормализация.

---

## 1. Где мы остановились?

На прошлой лекции мы переводили хаос бизнес-требований в строгую и понятную **концептуальную модель** т.е.  **ER-диаграмму**.

**Задача на сегодня:** Взять этот чертеж и превратить его в **логический план**, который поймет любая реляционная СУБД (PostgreSQL, MySQL и др.).

> **Концептуальная модель (ERD) ➡️ Логическая модель (Реляционная схема)**

---
## 2. Язык реляционной модели

Реляционная модель, предложенная Эдгаром Коддом, основана на простой и мощной идее: все данные представлены в виде таблиц.

| Формальный термин        | Аналог в СУБД              | Описание                                         |
| :----------------------- | :------------------------- | :----------------------------------------------- |
| **Отношение (Relation)** | **Таблица (Table)**        | Двумерная структура из строк и столбцов          |
| **Кортеж (Tuple)**       | **Строка (Row)**           | Один экземпляр данных (один студент, один заказ) |
| **Атрибут (Attribute)**  | **Столбец (Column)**       | Именованная характеристика данных                |
| **Домен (Domain)**       | **Тип данных (Data Type)** | Множество всех допустимых значений для атрибута  |
**Схема отношения (Relation Schema):** Это "заголовок" таблицы. Формально: `R(A1, A2, ..., An)`, где R — имя отношения, а Ai — его атрибуты.
*Пример: `Students(StudentID, FIO, BirthDate)`*

**Схема базы данных (Database Schema):** Это совокупность всех схем отношений в базе данных.

---
### **Виды ключей: Как мы идентифицируем данные**

Ключи — это не просто "уникальные поля". У них есть строгая иерархия.

1.  **Суперключ (Superkey):**
    *   **Определение:** *Любой* набор из одного или более атрибутов, значения которых уникально определяют каждый кортеж в отношении.
    *   *Пример для `Students(StudentID, FIO, Email)`:* `(StudentID)` — суперключ. `(Email)` — суперключ. `(StudentID, FIO)` — тоже суперключ (хоть и избыточный).

2.  **Потенциальный ключ (Candidate Key):**
    *   **Определение:** Это **минимальный** суперключ. То есть такой суперключ, из которого нельзя удалить ни одного атрибута без потери свойства уникальности.
    *   *Пример:* `(StudentID)` и `(Email)` — потенциальные ключи. А `(StudentID, FIO)` — нет, потому что FIO можно убрать, и уникальность сохранится.

3.  **Первичный ключ (Primary Key, PK):**
    *   **Определение:** Это тот **потенциальный ключ**, который разработчик базы данных выбрал в качестве основного идентификатора кортежей.
    *   *Выбор:* Обычно выбирают самый простой, стабильный и короткий ключ (часто это суррогатный id).

4.  **Альтернативный ключ (Alternate Key):**
    *   **Определение:** Любой потенциальный ключ, который **не** был выбран в качестве первичного.
    *   *Пример:* Если мы выбрали `StudentID` как PK, то `Email` становится альтернативным ключом. На него тоже нужно вешать ограничение `UNIQUE`.

#### **Внешний ключ (Foreign Key, FK)**
*   **Что это?** Атрибут (или группа атрибутов) в одной таблице, который ссылается на **первичный ключ** в другой таблице.
*   **Задача:** Установить и поддерживать связь между таблицами. Это и есть наш "клей".
*   **Пример:** `DepartmentID` в таблице `Employees` ссылается на `DepartmentID` в таблице `Departments`.
---
### **Ограничения целостности**

Это правила, которые не позволяют базе данных превратиться в "свалку" противоречивых данных.

| Тип ограничения                                      | Описание                                                                                                                                                                                                  | Пример в SQL                                                                            |
| :--------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------- |
| **1. Целостность доменов (Domain Integrity)**        | Значение каждого атрибута должно соответствовать его домену (типу данных).                                                                                                                                | `Age INT`, `BirthDate DATE`. Попытка вставить строку "Вася" в `Age` будет отклонена.    |
| **2. Целостность сущностей (Entity Integrity)**      | Ни один атрибут, входящий в состав **первичного ключа**, не может принимать значение `NULL`.                                                                                                              | `StudentID INT PRIMARY KEY`. Нельзя создать студента с `StudentID = NULL`.              |
| **3. Ссылочная целостность (Referential Integrity)** | Если в отношении R1 есть **внешний ключ (FK)**, ссылающийся на PK отношения R2, то значение этого FK в каждом кортеже R1 должно либо быть `NULL`, либо совпадать со значением PK некоторого кортежа в R2. | В таблице `Orders` есть `CustomerID`. Нельзя создать заказ для несуществующего клиента. |
| **4. Ограничения ключа (Key Constraints)**           | Никакие два кортежа в отношении не могут иметь одинаковых значений по атрибутам **потенциального ключа**.                                                                                                 | `Email VARCHAR(255) UNIQUE`. Нельзя создать двух пользователей с одинаковым email.      |

---
## 4. Алгоритм трансформации

Это почти механический процесс. Следуйте правилам, и вы получите корректную схему.
### Правило 1: Сильные сущности
Каждая сильная сущность на ER-диаграмме превращается в отдельную таблицу. Атрибуты сущности становятся столбцами этой таблицы.

**Students(<u>StudentID</u>, Name, Semester)**
**Lectures(<u>LecID</u>, Title, CP)**

---
### Правило 2: Связь Один-ко-Многим (1:N)
Ключ со стороны "1" **мигрирует** в таблицу на стороне "N" в качестве внешнего ключа.

```
// Таблица на стороне "1"
Departments(DepartmentID, Name)

// Таблица на стороне "N"
// DepartmentID "мигрировал" сюда как внешний ключ
Employees(EmployeeID, FIO, DepartmentID)
```
*Внешний ключ `Employees.DepartmentID` ссылается на `Departments.DepartmentID`.*

---
### Правило 3: Связь Многие-ко-Многим (M:N)
Такие связи нельзя реализовать напрямую. Мы создаем **третью, ассоциативную (связующую) таблицу**.

*   Первичный ключ этой новой таблицы получается как **композиция** первичных ключей из двух исходных таблиц.
*   Если у самой связи были атрибуты (например, "оценка" в связи "студент-изучает-курс"), они становятся столбцами в этой новой таблице.

```
Students(StudentID, FIO)
Courses(CourseID, Title)

// Новая ассоциативная таблица
Enrollments(StudentID, CourseID, Grade) 
```
*Первичный ключ таблицы `Enrollments` (`StudentID`, `CourseID`).*
*`Enrollments.StudentID` ссылается на `Students.StudentID`.*
*`Enrollments.CourseID` ссылается на `Courses.CourseID`.*

---
### Правило 4: Связь Один-к-Одному (1:1)
Есть два основных подхода:

1.  **Слияние:** Если связь обязательна с обеих сторон (каждый сотрудник *обязан* иметь паспорт), можно объединить сущности в одну таблицу.
2.  **Миграция ключа (как в 1:N):** Более гибкий вариант. PK одной таблицы становится FK в другой. Чтобы сохранить ограничение 1:1, на столбец с внешним ключом нужно добавить ограничение `UNIQUE`.

---
### Правило 5: Слабые сущности
Слабая сущность также становится таблицей, но ее первичный ключ **всегда составной**.

*   Он включает в себя **первичный ключ родительской (сильной) сущности** и **частичный ключ** самой слабой сущности.

```
Buildings(BuildingID, Address)

// PK родителя (BuildingID) становится частью PK дочерней таблицы
Rooms(BuildingID, RoomNumber, Capacity) 
```
*Первичный ключ таблицы `Rooms` (`BuildingID`, `RoomNumber`).*
*`Rooms.BuildingID` также является внешним ключом к `Buildings.BuildingID`.*

---
### Правило 6: Иерархии ISA (Наследование)
Есть три стратегии. Выбор зависит от специфики задачи (что важнее: скорость запросов, отсутствие `NULL` или целостность).

1.  **Одна большая таблица:** Создать одну таблицу для родительской сущности, включив в нее атрибуты всех дочерних. Добавить столбец `EntityType` (`'Student'`, `'Professor'`).
    *   **Плюс:** Нет `JOIN`'ов. Быстро.
    *   **Минус:** Много `NULL`-значений.

2.  **Таблица на каждый "лист":** Создать таблицы только для конечных дочерних сущностей (`Students`, `Assistants`). Общие атрибуты родителя дублируются в каждой.
    *   **Плюс:** Нет `NULL`'ов.
    *   **Минус:** Дублирование схемы. Сложно запросить всех "людей" сразу.

3.  **Таблица на каждую сущность (самый "правильный"):** Создать таблицу для родителя и для каждого потомка. Дочерние таблицы содержат только свои уникальные атрибуты и внешний ключ, ссылающийся на PK родителя.
    *   **Плюс:** Максимальная нормализация, нет дублирования и `NULL`'ов.
    *   **Минус:** Требуются `JOIN`'ы для получения полной информации.
---
### Правило 7: Атрибуты связей

Переносятся в ассоциативные таблицы (для M:N) или в таблицу на стороне "N" (для 1:N).

---
### **Сводка правил трансформации**

*   **Правило 1 (Сильные сущности):** Превращаются в отношения. Выбор PK реализует **ключевое ограничение** и **целостность сущностей**.
*   **Правило 2 (Связь 1:N):** Миграция PK со стороны "1" в качестве FK на сторону "N". Это напрямую реализует **ссылочную целостность**.
*   **Правило 3 (Связь M:N):** Создание ассоциативного отношения, чей PK является композицией PK исходных отношений. Каждый из этих компонентов является FK, реализуя **ссылочную целостность** с обеими таблицами.
*   **Правило 4 (Связь 1:1):** Миграция ключа с установкой `UNIQUE` на FK. `UNIQUE` реализует **ключевое ограничение**, а сам FK — **ссылочную целостность**.
*   **Правило 5 (Слабые сущности):** PK родителя мигрирует и становится частью PK потомка. Это особый случай, где один и тот же столбец является частью PK (обеспечивая **целостность сущностей**) и одновременно FK (обеспечивая **ссылочную целостность**).
*   **Правило 6 (Иерархии ISA):** В варианте "таблица на сущность" PK родителя мигрирует в дочерние таблицы, где он является одновременно и PK, и FK.
*   **Правило 7 (Атрибуты связей):** Переносятся в ассоциативные таблицы (для M:N) или в таблицу на стороне "N" (для 1:N).

---
## 5. Кейс: Трансформация ER-схемы коворкинга

**Задача:** Спроектировать ER-диаграмму для системы бронирования коворкинга.

**Требования:**
1.  Есть `Пользователи`. У всех есть ФИО и email. Пользователи делятся на `Резидентов` (с тарифным планом) и `Гостей`.
2.  Есть `Помещения` для бронирования (переговорки, кабинеты). У них есть ID и вместимость.
3.  В некоторых `Помещениях` есть `Рабочие_места` с номером, уникальным только в пределах этого помещения.
4.  Пользователи делают `Бронирования`, указывая время. Бронировать можно как `Помещение` целиком, так и отдельное `Рабочее_место`.
5.  Каждое бронирование генерирует `Счет` на оплату.

**Процесс мышления и результат:**

1.  **Выделяем сущности (существительные):** `Пользователь`, `Резидент`, `Гость`, `Помещение`, `Рабочее_место`, `Бронирование`, `Счет`.
2.  **Применяем ISA:** `Резидент` и `Гость` — это виды `Пользователя`. Создаем иерархию.
3.  **Ищем слабую сущность:** `Рабочее_место` не может существовать без `Помещения`, и его номер уникален только внутри него. Это классический кандидат в слабую сущность.
4.  **Определяем связи и кардинальность:**
    *   `Пользователь` делает много `Бронирований` (1:N).
    *   `Бронирование` относится к одному `Помещению` ИЛИ к одному `Рабочему_месту` (это эксклюзивная связь, сложный случай).
    *   `Бронирование` порождает один `Счет` (1:1).
    *   `Помещение` содержит много `Рабочих_мест` (идентифицирующая связь 1:N).
    * 

![[Pasted image 20250917123607.png]]
**Реляционная схема:**

```
// Правило 6 (ISA): Таблица на каждую сущность
Users(UserID, FIO, Email)

Residents(UserID, TariffPlanID) // PK и FK одновременно
Guests(UserID, VisitDate)        // PK и FK одновременно

// Правило 1: Сильная сущность
Premises(PremiseID, Name, Capacity)

// Правило 5: Слабая сущность
Workplaces(PremiseID, WorkplaceNumber, Description) // PK = (PremiseID, WorkplaceNumber)

// Правило 1 + Правило 2
Bookings(BookingID, StartTime, EndTime, UserID, PremiseID, WorkplaceNumber)

// Правило 2: Связь 1:N
Invoices(InvoiceID, Amount, Status, BookingID)```
```
Разберем варианты таблиц для бронирований.
### **Вариант 1: Раздельные таблицы бронирований (Простой и надежный)**
Две независимые таблицы для каждого типа бронирования.
*   `PremiseBookings(BookingID, StartTime, EndTime, UserID, PremiseID)`
*   `WorkplaceBookings(BookingID, StartTime, EndTime, UserID, PremiseID, WorkplaceNumber)`
**Плюсы:**
*   Максимальная простота и очевидность.
*   Жесткая ссылочная целостность, все внешние ключи `NOT NULL`.
**Минусы:**
*   Дублирование полей (`StartTime`, `EndTime`, `UserID`) в обеих таблицах.
*   Чтобы получить *все* бронирования одного пользователя, придется объединять две таблицы, что может быть неудобно.
### **Вариант 2: Супертип и подтипы (Более гибкий и масштабируемый)**
Разделяем общие и специфичные данные о бронировании.
1.  Создается общая таблица **`Bookings`** (супертип) со всеми общими атрибутами.
2.  Создаются таблицы-подтипы для каждой конкретной связи.
*   `Bookings(BookingID, StartTime, EndTime, UserID, InvoiceID)` — общая информация.
*   `BookedPremises(BookingID, PremiseID)` — таблица-связка для брони помещений.
*   `BookedWorkplaces(BookingID, PremiseID, WorkplaceNumber)` — таблица-связка для брони рабочих мест.
В таблицах-подтипах `BookingID` является одновременно **и первичным, и внешним ключом**, ссылающимся на `Bookings.BookingID`. Это гарантирует, что одно бронирование может быть связано только с чем-то одним.

**Плюсы:**
*   Нет дублирования данных.
*   Жесткая ссылочная целостность.
*   Получить все бронирования пользователя — простой `SELECT` из таблицы `Bookings`.
*   Легко добавлять новые типы бронируемых объектов (например, `BookedEquipment`), не меняя существующую схему.

### **Полный список внешних ключей (Foreign Keys)**

`Residents(UserID)` -> `Users(UserID)`
`Guests(UserID)` -> `Users(UserID)`
`Workplaces(PremiseID)`  ->  `Premises(PremiseID)`
`Bookings(UserID)`  ->  `Users(UserID)`
`Bookings(InvoiceID)`  ->  `Invoices(InvoiceID)`
`BookedPremises(BookingID)`  ->  `Bookings(BookingID)`
`BookedPremises(PremiseID)`  ->  `Premises(PremiseID)`
`BookedWorkplaces(BookingID)`  -> `Bookings(BookingID)`
`BookedWorkplaces(PremiseID, WorkplaceNumber)`  -> `Workplaces(PremiseID, WorkplaceNumber)`

---
## 6. Что дальше?

Мы получили формально корректный набор таблиц. Но есть проблема. Наша схема может содержать **избыточность** и быть подвержена **аномалиям обновления, удаления и вставки**.

**Пример аномалии:**
В таблице `(StudentID, StudentFIO, CourseID, CourseTitle)` ФИО студента будет повторяться для каждого курса, на который он записан. Если он сменит фамилию, нам придется обновить **много** строк, и мы рискуем сделать это не везде.

**Решение?** Процесс **нормализации**, который мы изучим на следующей лекции. Он позволяет привести схему к виду, минимизирующему избыточность.


