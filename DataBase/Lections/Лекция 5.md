### **Лекция 5: Высшие нормальные формы (4НФ, 5НФ) и общая картина**

## Проектирование без аномалий: завершающие штрихи

---

## План на сегодня

1.  **Наш фундамент:** Где мы остановились? Краткий итог по 3НФ/BCNF.
2.  **Четвертая нормальная форма (4НФ):**
    *   **Проблема:** "Таблица-комбайн" и аномалии с несвязанными списками.
    *   **Диагностика:** Многозначные зависимости (МЗД) — формализуем здравый смысл.
    *   **Лечение:** Декомпозиция ортогональных фактов.
    *   **Главный инсайт:** Почему грамотное ER-моделирование — лучшая прививка от нарушения 4НФ.

3.  **Пятая нормальная форма (5НФ):**
    *   **Проблема:** "Призрачные" данные, возникающие из ниоткуда.
    *   **Диагностика:** Зависимости соединения (ЗС) — когда декомпозиция опасна.
    *   **Лечение (или отказ от него):** Как не потерять скрытое бизнес-правило.
    *   **Главный инсайт:** Почему иногда избыточность — это не баг, а фича, обеспечивающая целостность.

4.  **Итоги и прагматика:** Полная карта нормальных форм. Что и когда использовать на практике.

---

### **1. Наш фундамент: Мир после BCNF**

К этому моменту мы умеем строить схемы в 3НФ/BCNF. Наши таблицы решили проблемы с атомарностью, частичными и транзитивными зависимостями. Все неключевые атрибуты теперь зависят от "ключа, всего ключа и ничего кроме ключа".

Кажется, что все аномалии устранены. Но это касается только **однозначных** зависимостей (когда одному значению `A` соответствует **одно** значение `B`).

А что, если одному `A` соответствует **множество** `B` и **множество** `C`, причем эти множества независимы друг от друга?

---

### **2. Четвертая нормальная форма (4НФ)**

#### **Проблема: "Таблица-комбайн"**

Представьте, что мы по неопытности или по глупости решили хранить информацию о сотрудниках, их навыках и языках, которыми они владеют, в одной таблице. Сотрудник может иметь много навыков и знать много языков.

**`EmployeeSkillsLanguages`**
(<u>EmployeeID</u>, <u>Skill</u>, <u>Language</u>)  <-- *Первичный ключ составной из всех трех колонок*

| EmployeeID | Skill | Language |
| :--- | :--- | :--- |
| 101 | Java | English |
| 101 | Java | German |
| 101 | Python | English |
| 101 | Python | German |
| 102 | SQL | French |

**Что здесь не так?**

1.  **Чудовищная избыточность:** Чтобы добавить сотруднику №101 новый навык 'Go', нам придется создать **две** новые строки: `(101, Go, English)` и `(101, Go, German)`. Мы вынуждены создавать искусственные комбинации.
2.  **Аномалии обновления и удаления:** Если сотрудник №101 разучится программировать на Java, нам придется удалить две строки. Если он был единственным, кто знает немецкий, мы потеряем сам факт существования немецкого языка в нашей системе.

Проблема в том, что **навыки сотрудника и языки, которые он знает, — это два независимых, ортогональных факта о нем**. Мы искусственно создали декартово произведение его навыков на его языки.

#### **Диагностика: Многозначная зависимость (МЗД)**

Эта проблема формально описывается с помощью многозначной зависимости.

**Определение:** В отношении `R(A, B, C)` существует многозначная зависимость `A →→ B` (читается "A многозначно определяет B"), если для каждого значения `A` существует **множество** значений `B`, и это множество **не зависит** от значений `C`.

В нашем примере:
*   `EmployeeID →→ Skill` (Набор навыков сотрудника не зависит от того, какие языки он знает).
*   `EmployeeID →→ Language` (Набор языков не зависит от его навыков).

#### **Лечение: Четвертая нормальная форма (4НФ)**

*   **Формальное требование:** Отношение находится в 4НФ, если оно находится в BCNF и в нем отсутствуют нетривиальные многозначные зависимости, в которых детерминант (левая часть) не является суперключом.
*   **Простыми словами:** **Не храните в одной таблице несколько независимых "списочных" характеристик одного и того же объекта.**
*   **Решение (Декомпозиция):** Разделить каждый независимый многозначный факт в свою таблицу.

**`EmployeeSkillsLanguages` →**

1.  **`EmployeeSkills`**(<u>EmployeeID (FK)</u>, <u>Skill</u>)
2.  **`EmployeeLanguages`**(<u>EmployeeID (FK)</u>, <u>Language</u>)

Теперь избыточность и аномалии исчезли. Чтобы добавить новый навык, мы добавляем одну строку в одну таблицу.

#### **Главный инсайт по 4НФ**

Заметьте, к чему мы пришли после декомпозиции. Мы получили две таблицы, которые **естественным образом** получились бы, если бы мы изначально правильно сделали ER-модель!

Мы бы определили сущности `Сотрудник`, `Навык`, `Язык` и создали бы две связи M:N: "Сотрудник-обладает-Навыком" и "Сотрудник-владеет-Языком". При трансляции в реляционную модель эти связи превратились бы именно в таблицы `EmployeeSkills` и `EmployeeLanguages`.

> **Вывод:** 4НФ — это формальное математическое обоснование того, почему нельзя "сваливать в одну кучу" ортогональные, несвязанные характеристики объекта. **Если вы хорошо делаете концептуальное моделирование, вы, скорее всего, никогда сознательно не нарушите 4НФ.**

---

### **3. Пятая нормальная форма (5НФ)**

Эта форма самая эзотерическая, но она раскрывает очень глубокую идею о целостности данных.

#### **Проблема: "Призрачные" данные**

Рассмотрим таблицу, которая находится в 4НФ. Она показывает, какой агент какой компании может продавать какой продукт.

**`Offerings`**
(<u>Agent</u>, <u>Company</u>, <u>Product</u>)

| Agent | Company | Product |
| :--- | :--- | :--- |
| Смит | Acme | Пылесосы |
| Смит | Stark | Тостеры |
| Джонс | Acme | Пылесосы |
| Джонс | Acme | Гаджеты |

Кажется, здесь есть избыточность. Например, "Acme" и "Пылесосы" повторяются. Может, разложим ее на три таблицы, как нас учит 4НФ?

*   `AgentCompany(Agent, Company)`
*   `CompanyProduct(Company, Product)`
*   `AgentProduct(Agent, Product)`

Давайте посмотрим, что будет в этих таблицах, и попробуем собрать (`JOIN`) их обратно.

| Agent | Company |
| :--- | :--- |
| Смит | Acme |
| Смит | Stark |
| Джонс | Acme |

| Company | Product |
| :--- | :--- |
| Acme | Пылесосы |
| Acme | Гаджеты |
| Stark | Тостеры |

| Agent | Product |
| :--- | :--- |
| Смит | Пылесосы |
| Смит | Тостеры |
| Джонс | Пылесосы |
| Джонс | Гаджеты |

Теперь соединим их обратно (`SELECT * FROM AgentCompany JOIN CompanyProduct JOIN AgentProduct ...`). Что мы получим? Мы получим **все** исходные строки... **и еще одну!**

| Agent | Company | Product |
| :--- | :--- | :--- |
| ... | ... | ... |
| **Смит** | **Acme** | **Тостеры** | <-- **"Призрак"**!

Наша декомпозиция породила ложный факт: теперь система считает, что Смит может продавать тостеры от компании Acme, хотя в исходных данных этого не было!

#### **Диагностика: Зависимость соединения (ЗС)**

*   **Почему так произошло?** Потому что в исходной таблице было скрыто **неявное бизнес-правило**: "Агент может предлагать продукт компании X, **только если** (1) он работает на компанию X, **И** (2) он авторизован продавать этот тип продукта, **И** (3) компания X производит этот продукт".
*   Это правило связывает **все три** атрибута вместе. Его нельзя разложить на пары без потери смысла.
*   **Формальное определение:** Отношение `R` удовлетворяет **зависимости соединения**, если его можно разложить на несколько проекций (таблиц) `R1, R2, ..., Rn` так, что при их обратном соединении мы получаем в точности исходное отношение `R`, без потерь и без "призраков". Наша таблица `Offerings` **не удовлетворяла** ЗС по выбранным нами проекциям.

#### **Лечение: Пятая нормальная форма (5НФ)**

*   **Формальное требование:** Отношение находится в 5НФ, если оно находится в 4НФ и каждая нетривиальная зависимость соединения в нем определяется потенциальным ключом.
*   **Простыми словами:** **Нельзя раскладывать таблицу на части, если при этом теряется важное многостороннее бизнес-правило.**
*   **Решение:** Оставить таблицу `Offerings` **как есть**. Ее избыточность — это не ошибка проектирования, а необходимое условие для сохранения целостности данных.

*Пятая нормальная форма также известна как проекционно-соединительная нормальная форма (PJNF). "Проекционная" — потому что мы говорим о декомпозиции (проекции) таблицы на несколько меньших. "Соединительная" — потому что мы требуем, чтобы при их обратном соединении (`JOIN`) не возникало "призраков" и не терялись данные.
#### **Главный инсайт по 5НФ**

Возвращаемся к вашей идее: "если не все комбинации значений допустимы, то в несколько таблиц раскладывать нельзя". **Это и есть суть 5НФ!**

5НФ формально описывает ситуацию, когда существует сложное правило, ограничивающее допустимые комбинации значений. В этом случае единственным способом обеспечить соблюдение этого правила является хранение всех связанных атрибутов в одной таблице.

> **Вывод:** 5НФ учит нас, что конечная цель — не максимальная декомпозиция, а **сохранение целостности и всех бизнес-правил**. Иногда для этого приходится мириться с контролируемой избыточностью.

---

### **4. Итоги и прагматика**

| НФ | Проблема, которую решает | Ключевая концепция |
| :--- | :--- | :--- |
| **1НФ** | Хаос, многозначные поля | Атомарность атрибутов |
| **2НФ** | Зависимость от части составного ключа | Частичная ФЗ |
| **3НФ** | Зависимость неключевых полей друг от друга | Транзитивная ФЗ |
| **BCNF** | Аномалии в редких случаях с пересекающимися ключами | Любой детерминант — суперключ |
| **4НФ** | Независимые "списки" в одной таблице | Многозначная зависимость |
| **5НФ** | Потеря бизнес-правил при декомпозиции | Зависимость соединения |

**Что использовать на практике?**

*   **Обязательный стандарт для OLTP-систем (обычные приложения): 3НФ.** Это золотой стандарт, обеспечивающий отличный баланс между устранением избыточности и сложностью схемы.
*   **BCNF:** Хорошо спроектированная 3НФ схема почти всегда будет и в BCNF. Стоит проверять на BCNF, если у вас сложные составные ключи.
*   **4НФ:** Достигается "автоматически" при грамотном концептуальном проектировании. Если вы видите, что нарушаете 4НФ, — это сигнал, что вы фундаментально неправильно поняли предметную область.
*   **5НФ:** Встречается крайне редко. Это скорее теоретический инструмент для анализа сложных ограничений, чем ежедневная практика. Но понимание ее сути защитит вас от неверной декомпозиции.

---

Мы с вами прошли путь от 1НФ до 5НФ, решая конкретные проблемы с аномалиями. Но теория на этом не заканчивается. Существуют еще три концепции, которые стоит знать. Они — не столько практические шаги, сколько ответ на вопрос: "А существует ли предел? Идеальная нормальная форма? И что, если нам нужно хранить не только данные, но и их историю?"
 
---
### **Доменно-ключевая нормальная форма (ДК/НФ, DKNF)**

*   **Что это?** Это теоретический идеал, "Святой Грааль" нормализации.
*   **Формальное требование:** Отношение находится в ДК/НФ, если **любое** ограничение целостности является логическим следствием только **ограничений доменов** и **ограничений ключей**.
*   **Суть простыми словами:** Представьте себе идеальную схему, где для обеспечения целостности данных вам **вообще не нужен код на стороне приложения**. Любое бизнес-правило, каким бы сложным оно ни было, обеспечивается самой структурой базы данных:
    *   `PRIMARY KEY / UNIQUE` (ограничения ключей)
    *   `FOREIGN KEY` (ссылки на ключи)
    *   `CHECK` constraints (ограничения доменов)
    *   Типы данных (ограничения доменов)
    *   `NOT NULL` (ограничение домена)

    В ДК/НФ нет необходимости в сложных триггерах или процедурах для поддержания консистентности. Схема самодостаточна и самодокументируема. Если данные можно вставить в таблицы, значит, они корректны с точки зрения бизнес-правил.

*   **Практическая ценность:**
    1.  **Это не пошаговая инструкция, а философия проектирования.** В реальных сложных системах достичь "чистой" ДК/НФ практически невозможно.
    2.  **Но! Стремление к ДК/НФ — это мощнейший инструмент аналитика.** При проектировании вы должны постоянно задавать себе вопрос: "А могу ли я выразить это бизнес-правило декларативно, через ограничения СУБД, а не процедурно, через код?". Чем чаще ответ "Да", тем надежнее и проще в поддержке будет ваша система.

---

### **Шестая нормальная форма (6НФ)**

*   **Что это?** Максимальная, атомарная декомпозиция.
*   **Формальное требование:** Отношение находится в 6НФ, если оно состоит из первичного ключа и **не более чем одного** неключевого атрибута.
*   **Суть простыми словами:** Берем обычную таблицу и разрываем ее на множество маленьких таблиц "ключ-значение". Зачем это безумие?

    Представим таблицу `Сотрудники(ID, Имя, Должность, Зарплата)`.
    В 6НФ она превратится в:
    *   `ИменаСотрудников(ID, Имя)`
    *   `ДолжностиСотрудников(ID, Должность)`
    *   `ЗарплатыСотрудников(ID, Зарплата)`

*   **Практическая ценность: Работа со временем (темпоральные данные).**
    А теперь добавим в каждую из этих таблиц два поля: `ValidFrom` (Действует С) и `ValidTo` (Действует По).
    *   `ИменаСотрудников(ID, Имя, ValidFrom, ValidTo)`
    *   `ДолжностиСотрудников(ID, Должность, ValidFrom, ValidTo)`
    *   `ЗарплатыСотрудников(ID, Зарплата, ValidFrom, ValidTo)`

    **Что мы получили?**
    1.  **Полную историю изменений каждого атрибута независимо друг от друга!** Если у сотрудника сменилась должность, мы просто закрываем старую запись (ставим `ValidTo`) в таблице должностей и добавляем новую. Таблицы с именем и зарплатой мы вообще не трогаем!
    2.  **Гибкость схемы:** Добавить новый атрибут сотруднику (например, `НомерКабинета`) — значит просто добавить новую таблицу `КабинетыСотрудников(...)`, не меняя (не блокируя) огромную центральную таблицу `Сотрудники`.

    Этот подход широко используется в **хранилищах данных (DWH)**, особенно в методологиях **Data Vault** и **Anchor Modeling**, а также в системах, где аудит и история изменений критически важны (финансы, медицина).

### **Итоговая карта нормальных форм**

| НФ              | Проблема, которую решает                    | Ключевая концепция                         |
| :-------------- | :------------------------------------------ | :----------------------------------------- |
| **1НФ**         | Хаос, многозначные поля                     | Атомарность атрибутов                      |
| **2НФ**         | Зависимость от части составного ключа       | Частичная ФЗ                               |
| **3НФ**         | Зависимость неключевых полей друг от друга  | Транзитивная ФЗ                            |
| **BCNF**        | Аномалии с пересекающимися ключами          | Любой детерминант — суперключ              |
| **4НФ**         | Независимые "списки" в одной таблице        | Многозначная зависимость                   |
| **5НФ (ПС/НФ)** | Потеря бизнес-правил при декомпозиции       | Зависимость соединения                     |
| **6НФ**         | Отслеживание истории изменений атрибутов    | Максимальная декомпозиция (темпоральность) |
| **ДК/НФ**       | **(Идеал)** Обеспечение любых бизнес-правил | Ограничения доменов и ключей               |
